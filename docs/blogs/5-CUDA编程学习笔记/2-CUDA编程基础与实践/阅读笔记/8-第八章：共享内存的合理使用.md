共享内存是一种可被程序员直接操控的缓存，主要作用有两个：
- 一个是减少核函数中对全局内存的访问次数，实现高效的<font color='red'><b>线程块内部的通信</b></font>。
- 另一个是提高全局内存访问的合并度。

## 8.1-例子：数组归约计算
一个普通的CPU归约例子，如下所示：
```cpp
double reduce(const double *x, const int N)
{
    double sum = 0.0;
    for (int n = 0; n < N; ++n)
    {
        sum += x[n];
    }
    return sum;
}
```


### 8.1.1-仅使用全局内存

对于数组归约的并行计算问题，需要从一个数组出发，最终得到一个数，所以，必须使用某种迭代方案。

假如数组元素的个数是2的整数次方，因此可以将数组后半部分的各个元素与前半部分对应的数组元素相加。如果重复此过程，最后得到的第一个数组元素就是最初的数组中各个元素的和。

<div style={{textAlign:'center'}}><img src="https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20240929154608.png" width="300"/></div>
这就是所谓的折半归约法。

由于是多线程环境，归约需要保证执行的顺序性，因此，需要借助函数`__syncthreads()`函数来进行实现。而该函数的作用范围是一个线程块内，因此，可以采用块内归约的方式进行。（全局内存，块内归约）

```cpp
__global__ void reduce_global(double *d_x, double *d_y)
{
    const int tid = threadIdx.x;
    double *x = d_x + blockDim.x * blockIdx.x; // 找到这一段数组数据的起始地址
    for (int offset = blockDim.x >> 1; offset > 0; offset >>= 1)
    {
        if (tid < offset)
        {
            x[tid] += x[tid + offset];
        }
        __syncthreads();
    }
    if (tid == 0)
    {
        d_y[blockIdx.x] = x[0];
    }
}
```

在各个线程块内对其中的数据独立地进行归约，每个线程块都处理不同的数据，相互之间没有依赖。总结来说就是，一个线程块内的线程需要合作，所以需要同步；两个线程块之间不需要合作，所以不需要同步。

同时，需要注意的是，将`blockDim.x/2`写成了`blockDim.x>>1`，并将`offset = offeset / 2` 写成了`offset = offset >> 1`，这是利用了位操作。在核函数中，<font color='red'><b>位操作比对应的整数操作高效</b></font>。

### 8.1.2-使用共享内存

全局内存的访问速度是所有内存中最低的，应该尽量减少对它的使用。所有设备内存中，寄存器是最高效的，但在需要线程合作的问题中，用仅对单个线程可见的寄存器是不够的。需要使用对整个线程块可见的共享内存。

在核函数中，要将一个变量定义为共享内存变量，就要在定义语句中加上一个限定符`__shared__`。一般情况下，<font color='red'><b>共享内存中设定的数组的长度等于线程块的大小</b></font>。

```cpp
__shared__ double s_y[128];
```

tips：共享内存的变量名，可以以`s_`为前缀。

需要注意的是：
- 在一个核函数中定义一个共享内存变量，就相当于在每一个线程块中有了一个该变量的副本。每个副本都不一样，即使它们共用一个变量名。核函数中对共享内存变量的操作都是同时作用在所有的副本上的。
- 共享内存变量的生命周期仅仅在核函数内，所以**必须在核函数结束之前将共享内存中的某些结果保存到全局内存**中。

使用静态共享内存的归约函数：
```cpp
__global__ void reduce_shared(double *d_x, double *d_y)
{
    const int tid = threadIdx.x;
    const int bid = blockIdx.x;
    const int n = bid * blockDim.x + tid;
    __shared__ double s_y[128];            // 这里需要根据线程块的大小去自定义
    s_y[tid] = (n < N) ? d_x[n] : 0.0;     // 将数据从全局内存拷贝到共享内存中（可能是合并访问的）
    __syncthreads();
    for (int offset = blockDim.x >> 1; offset > 0; offset >>= 1)
    {
        if (tid < offset)
        {
            s_y[tid] += s_y[tid + offset];
        }
        __syncthreads();
    }
    if (tid == 0)
    {
        d_y[bid] = s_y[0];                 // 计算完成后，将共享内存中的数据，及时拷贝回主机
    }
}
```

使用共享内存减少全局内存访问一般来说会带来性能的提升，但也不是绝对如此。一般来说，在核函数中对共享内存访问的次数越多，则由使用共享内存带来的加速效果越明显。

在数组归约问题中，使用共享内存相对于仅使用全局内存还有两个好处：
- 一是不再要求全局内存数组的长度N是线程块大小的整数倍。
- 另一个是在归约的过程中，不会改变全局内存数组中的数组。

### 8.1.3-使用动态共享内存

使用动态共享内存，也就是共享内存的大小在外面可以根据变量来进行指定，不需要写死在核函数中。

将静态共享内存变为动态共享内存有两个步骤：
- 1. 在调用核函数的执行配置中，添加第三个参数，该参数表示共享内存的大小。
	- `<<<grid_size, block_size, sizeof(double)*block_size>>>();`
- 2. 改变核函数中共享内存变量的声明方式
	- `extern __shared__ double s_y[];`
	- 这与之前声明的静态共享内存有两处不同
		- 第一：必须加上限定词extern；
		- 第二：不能指定数组的大小；

Tips：**使用动态共享内存的核函数与使用静态共享内存的核函数在执行时间上几乎没有差别**。所以，使用动态共享内存不会影响程序性能，但有时可提高程序的可维护性。

## 8.2-使用共享内存进行矩阵转置

由于矩阵转置的操作，会使得读写内存两者不能得兼的同时访问，只能舍弃一个。而由于具有共享内存这个中间件之后，就可以避免这种情况，从而使得读写内存在矩阵转置操作下，这两者都可以合并进行访问。也就是说：共享内存还有一个作用，就是<font color='red'><b>改善全局内存的访问方式</b></font>（将非合并的全局内存访问转化为合并的）。

## 8.3 避免共享内存的bank冲突 ⭐️

在共享内存中，有一个<font color='red'><b>内存bank</b></font>的概念非常重要！为了获得高的内存带宽，**共享内存在物理上被分为32个**（一个线程束中的线程数目）**同样宽度的，能被同时访问的内存bank**。 <font color='red'><b>每个bank可以在同一时钟周期内服务一个线程的访问请求</b></font>。由于bank的这个特性，故有了bank冲突访问和无冲突访问：
- 无冲突访问：
	- 多个线程同时访问位于不同bank中的数据，访问可以并行进行。
- 冲突访问：
	- 多个线程在同一时钟周期内访问同一个bank中的不同地址，就发生了bank冲突（bank conflict）。
	- 当发生bank冲突时，访问将被串行化，导致性能的下降。

bank的大小：
- 在开普勒架构之前，bank的大小为<font color='red'><b>4B</b></font>，为一个int型或float型的大小。
- 在开普勒架构之后，比如安培架构，bank的大小变为<font color='red'><b>8B</b></font>，一个double或longlong的大小。

对于bank宽度为4字节的架构，共享内存数组是按照如下方式线性地映射到内存bank的：**共享内存数组中连续的128字节的内容分摊到32个bank的某一层中，每个bank负责4字节的内容**。

<div style={{textAlign:'center'}}><img src="https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/202409292053677.png" width="100%"/></div>

只要同一线程束内的多个线程不同时访问同一个bank中不同层的数据，该线程束对共享内存的访问就只需要一次内存事务（memory transaction）。当同一线程束内的多个线程试图访问同一个bank中不同层的数据时，就会发生bank冲突。**在一个线程束内对同一个bank中的n层数据同时访问将导致n次内存事务**。称为发生了n路bank冲突。