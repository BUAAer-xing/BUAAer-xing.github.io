# 知识补充

## 高性能计算中可扩展性强的含义

在高性能计算领域，"扩展性强"通常指的是计算系统或应用程序能够**有效地应对不断增加的计算工作负载**，而**无需显著增加硬件资源或性能下降**。


## LU分解

当**A的所有顺序主子式都不为0**时，矩阵A可以分解为A=LU。其中L是下三角矩阵，U是上三角矩阵。

### LU分解简介

LU分解是“矩阵因式分解”的一种，旨在将某个矩阵$A$表示为两个或多个矩阵的乘积。正如其名，LU分解是将矩阵$A$表示为$A=LU$，其中矩阵$L$代表Lower Triangular（下三角矩阵），矩阵$U$ 代表Upper Triangular（上三角矩阵）。形象一点就相当于写为 $A$=◣×◥。

比如下面这个例子：

$$
A=LU=\begin{bmatrix}1&0&0\\1&1&0\\-1&2&1\end{bmatrix}\begin{bmatrix}1&1&-1\\0&1&2\\0&0&1\end{bmatrix}
$$

### LU分解主要用途

LU主要用来加快求解方程组的速度，常用于二次型矩阵求解。**LU分解是接近中小规模、稠密矩阵的最好方法**。

$$
\begin{aligned}
Ax&=b \\
LUx&=b\\\Rightarrow x&=(LU)^{-1}b\\&=U^{-1}L^{-1}b\end{aligned}
$$

实际应用中，矩阵$A$往往是固定的，而右侧向量$b$经常会替换。当矩阵$A$被分解后，$LU$可充分利用，提高效率。

### LU分解的数学原理

- 基本假设
	1. 假设矩阵是正方形、可逆矩阵。
	2. 假设消元时不需要进行两行的交换。

假设我们有一个矩阵，这个矩阵作为例子贯穿全文：
$$
A=\begin{pmatrix}1&5&-3\\-2&-7&3\\4&9&6\end{pmatrix}
$$

通过对A做初等行变换，将A变为上三角矩阵U，变换过程如下：

![image.png|center](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20231012011250.png)

通过**左行右列**的原则，得出初等矩阵的乘法顺序，将矩阵A的消元过程写出来后，可进一步写为$E_{32}E_{31}E_{21}A=U$，此时距离LU分解的$A=LU$只差求逆了。

根据矩阵求逆的公式，$L=(E_{32}E_{31}E_{21})^{−1}=E_{21}^{−1}E_{31}^{−1}E_{32}^{−1}$

$$
L=(E_{32}E_{31}E_{21})^{-1}=\begin{pmatrix}1&0&0\\-2&1&0\\4&-11/3&1\end{pmatrix}
$$

可以惊喜的发现：观察矩阵$L=(E_{32}E_{31}E_{21})^{−1}$，其下三角的$(3,2),(3,1),(2,1)$位置恰好为对应**初等矩阵的相反数**(进行变换系数的相反数)，这样使得矩阵L只保留了最关键的消元信息！

### LU分解与配方法

举个例子，二次型如下：

$$
\begin{aligned}
f& =x_1^2+2x_2^2+6x_3^2+2x_1x_2-2x_1x_3+2x_2x_3  \\
&=(x_1+x_2-x_3)^2+(x_2+2x_3^2)+x_3^2
\end{aligned}
$$
将对应的系数矩阵A进行LU分解，可以得到：

![image.png|center](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20231012012308.png)

二次型矩阵进行$A=LU$分解**后$L$矩阵的列向量**是对应顺序的$(x_1,x_2 \ldots)$的**系数**,**而$U$矩阵对角线元素**(主元)则为**括号外的系数**。此外,$U$矩阵的主元元素乘积即为原矩阵的行列式的值


### 分解过程

LU分解是一种矩阵分解的方法，通常用于解线性方程组或计算矩阵的逆。它将**一个矩阵分解为一个下三角矩阵（L）和一个上三角矩阵（U）的乘积**，因此得名LU分解（LU decomposition）。

1. 初始化LU矩阵，L矩阵上三角为0，对角线为1，U矩阵下三角为0.

2. 计算U矩阵的第一行和L矩阵的第一列

3. 循环计算U矩阵和L矩阵，第一层循环表示U计算到第几行，同时也表示L计算到第几列，先计算U后计算L。第二层循环分别表示U矩阵改行的第几列元素。第三层循环就是公式中的求和符号部分。

利用C++实现LU分解：

```cpp
void luDecomposition(vector<vector<double>> &A, vector<vector<double>> &L, vector<vector<double>> &U)
{
    int n = A.size();
    // 先初始化L和U
    // 对U，转化为上三角矩阵
    for (int i = 1; i < n; i++)
    {
        for(int j=0; j<i; j++){
            U[i][j] = 0;
        }
    }
    // 对L，转化为下三角矩阵，同时对角线元素为1
    for(int i=0; i<n; i++){
        for(int j=i; j<n; j++){
            if(i==j) L[i][j] = 1;
            else {
                L[i][j] = 0;
            }
        }
    }
    for(int i=0; i<n; i++){
        // 先对U进行操作
        for(int j=i; j<n; j++){
            double sum = 0;
            //在求和过程中，对于L来说，变动的是它的列，行不变，对于U来说，变动的是它的行，列不变
            for(int k=0; k<i; k++){
                sum += L[i][k]*U[k][j];
            }
            // 第i行
            U[i][j] = A[i][j] - sum;
        }
        // 再对L进行操作
        for(int j=i; j<n; j++){
            if(j==i){}
            else{
                double sum = 0;
                for(int k=0; k<i; k++){
                    //在求和过程中，对于L来说，变动的是它的列，行不变，对于U来说，变动的是它的行，列不变
                   sum +=  L[j][k] * U[k][j];
                }
                // 第i列
                L[j][i] = (A[j][i] - sum) / U[i][i];
            }
        }
    }
    show(L,U);
}
```

需要注意的是，LU分解并不总是可行的，特别是当A的某些元素为零或非常接近零时，可能会出现数值稳定性问题。在这种情况下，可以考虑使用部分或完全主元LU分解，或者采用其他数值方法来解决线性方程组。

##    SuperLU_DIST

**SuperLU_DIST是一个并行稀疏矩阵直接解法库**，用于解决大型稀疏线性方程组的问题。它是SuperLU的一个扩展版本，专门设计用于分布式内存并行计算环境。SuperLU是一个用于解决稀疏线性方程组的软件包，而SuperLU_DIST则扩展了其功能，使其适用于分布式计算集群或超级计算机。

SuperLU_DIST旨在解决大规模科学和工程应用中的线性代数问题，这些问题通常涉及到数以百万或数以亿的未知数和大规模的稀疏矩阵。这些问题可以在多个处理器或计算节点上并行处理，以加速求解过程。SuperLU_DIST利用分布式内存计算的优势，通过将工作负载分布到多个计算节点上，以提高性能和可扩展性。

SuperLU_DIST的应用范围包括有限元分析、计算流体动力学、结构分析、地球科学模拟、材料建模等领域。它是一个强大的工具，用于解决需要高性能计算的复杂线性代数问题。如果您在使用大规模稀疏线性方程组的数值计算应用中遇到问题，SuperLU_DIST可能是一个有用的工具。


## 消元树

^ce9df6

在LU分解方法中，"**elimination tree**"（消元树）是一种数据结构，**用于描述如何进行高斯消元过程**，即如何将矩阵分解为一个下三角矩阵（L，Lower triangular）和一个上三角矩阵（U，Upper triangular）。消元树的主要目的是**帮助确定在哪个顺序下对矩阵的元素进行消元操作，以确保LU分解的正确性和稳定性**。

具体来说，消元树是一个树状结构，其中**每个节点对应于矩阵的一列或一行**。该树的根节点通常对应于矩阵的第一个列（或行），而**子节点对应于在进行LU分解时需要消除的列（或行）**。消元树的结构取决于矩阵的非零元素分布，以及分解的顺序。

通过遍历消元树，可以确定LU分解的顺序，确保在消元的过程中，每个非零元素都是在正确的时刻被使用和消除的。这有助于减小数值不稳定性，并提高LU分解的效率。在一些大规模稀疏矩阵的情况下，合理构建消元树可以减小计算和存储开销。

总之，消元树在LU分解方法中用于指导高斯消元过程的操作顺序，以确保分解的正确性和数值稳定性。不同的LU分解算法可能采用不同的策略来构建和利用消元树。

## 分隔符

在计算机科学和图论中，"separator"（分隔符）是一个常用的术语，**指的是在一个图或网络中，能够将图分成多个部分或组件的节点集合**。这个节点集合具有特定的性质，**当从图中删除这些节点后，原始图会分成两个或多个互不相连的子图**。分隔符在图分割、图分析和图算法中发挥重要作用。

以下是一些关于分隔符的常见情况和性质：

1. **最小分隔符（Minimum Separator）**：最小分隔符是指在一个图中，要将其分成两个或多个部分所需的最小节点集合。找到最小分隔符通常用于图分割算法和网络通信的优化，以便在网络中实现高效的通信或计算。

2. **双连通分隔符（Biconnected Separator）**：在无向图中，一个双连通分隔符是一个节点集合，删除它们会导致图分解为两个或更多双连通分量，这些分量在删除分隔符节点之前是连通的。这在关于图的连通性的问题中很有用。

3. **k-分隔符（k-Separator）**：k-分隔符是一个节点集合，当删除后，会将图分解为k个或更多的互不相连的部分。这在图的划分和分布式计算中有应用。

分隔符的概念在图分析、图划分、网络设计、图算法等领域非常有用。通过识别和使用分隔符，可以更好地理解和处理复杂图结构，同时优化图的划分、通信和计算问题。

## 并行稀疏LU分解消元树

### 1. 任务概述

并行稀疏LU分解消元树是一种用于高性能计算的算法，用于将稀疏矩阵分解为一个下三角矩阵和一个上三角矩阵的乘积。本文将介绍并行稀疏LU分解算法的原理、应用场景以及实现方法。

### 2. 算法原理

并行稀疏LU分解消元树算法是一种基于图论的算法。它通过构建一个消元树，将稀疏矩阵的LU分解过程划分为多个并行的子任务，从而提高计算效率。

2.1 消元树

消元树是一个有向无环图(Directed Acyclic Graph, DAG)，它表示了**稀疏矩阵的LU分解过程中的依赖关系**。树的根节点表示矩阵的第一行，叶子节点表示矩阵的最后一行。每个节点表示一个行向量，节点之间的边表示消元操作的依赖关系。

2.2 并行LU分解

并行LU分解通过并行地处理消元树中的节点，将稀疏矩阵分解为下三角矩阵和上三角矩阵。每个节点的处理包括两个步骤：前向消元和后向替换。

•前向消元：将当前节点所在的行向量与其前驱节点的行向量进行消元操作，得到当前节点的新行向量。

•后向替换：将当前节点的新行向量替换其后继节点的行向量中对应的元素。

并行LU分解的关键在于如何确定节点的处理顺序，以及如何合理地划分任务并进行并行计算。

### 3. 应用场景

并行稀疏LU分解消元树算法在科学计算领域有着广泛的应用。以下是一些常见的应用场景：

3.1 线性方程组求解

并行稀疏LU分解算法可以用于求解大规模的线性方程组。通过将系数矩阵进行LU分解，可以将求解线性方程组的复杂度从O(n3)降低到O(n2)，从而提高计算效率。

3.2 有限元分析

有限元分析是一种常见的数值计算方法，用于求解结构力学、流体力学等问题。并行稀疏LU分解算法可以应用于有限元分析中的线性方程组求解过程，提高计算效率。

3.3 图像处理

并行稀疏LU分解算法可以应用于图像处理中的图像恢复、图像分割等问题。通过将图像表示为稀疏矩阵，并进行LU分解，可以提高图像处理的速度和效果。

### 4. 总结

并行稀疏LU分解消元树算法是一种用于高性能计算的算法，可用于将稀疏矩阵分解为下三角矩阵和上三角矩阵的乘积。本文介绍了算法的原理、应用场景以及基本实现方法。通过合理地划分任务并进行并行计算，可以提高算法的计算效率，适用于大规模的科学计算问题。

##  舒尔补（Schur Compliment）

### 定义

给定任意的矩阵块$M$，如下所示：

$$\mathbf{M}=\begin{bmatrix}\mathbf{A}&\mathbf{B}\\\mathbf{C}&\mathbf{D}\end{bmatrix}$$

- 如果矩阵块$D$是可逆的，那么，$A-BD^{-1}C$称之为$D$关于M的舒尔补。
- 如果矩阵块$A$是可逆的，那么，$D-CA^{-1}B$称之为$A$关于M的舒尔补。

### 由来

舒尔补的由来就是将矩阵变为对角矩阵的过程，比如在线性方程$Ax=b$的求解过程中，如果手动去求解的话，就是将矩阵$A|b$化简为上三角矩阵或者下三角矩阵，用到的思想主要是**高斯消元法**。

所以，将上述M矩阵变成对角矩阵的过程就是求解舒尔补的过程：(注意：一个矩阵左乘以初等矩阵相当于对该矩阵进行**行操作**，一个矩阵右乘以初等矩阵，相等于对该矩阵进行**列操作**)

- 对M的操作为：第一行左乘以$-CA^{-1}$ 加到第二行上去

$$
\left.\left[\begin{array}
{cc}\mathbf{I}&\mathbf{0}\\
-\mathbf{CA}^{-1}&\mathbf{I}\end{array}\right.\right]\left[\begin{array}{cc}\mathbf{A}&\mathbf{B}\\\mathbf{C}&\mathbf{D}\end{array}\right]=\left[\begin{array}{cc}\mathbf{A}&\mathbf{B}\\\mathbf{0}&\Delta_\mathbf{A}\end{array}\right]
$$
- 对M的操作为：第一列右乘以$-A^{-1}B$加到第二列上面去
$$
\left.\left[\begin{array}{cc}\mathbf{A}&\mathbf{B}\\\mathbf{C}&\mathbf{D}\end{array}\right.\right]\left[\begin{array}{cc}\mathbf{I}&-\mathbf{A}^{-1}\mathbf{B}\\\mathbf{0}&\mathbf{I}\end{array}\right]=\left[\begin{array}{cc}\mathbf{A}&0\\\mathbf{C}&\Delta_\mathbf{A}\end{array}\right]
$$

这两个操作对应的$\Delta_A$ 都为A关于M的舒尔补，也就是$D-CA^{-1}B$。

### 应用

通过**左乘和右乘**，将矩阵M变成一个对角阵。有了$\Delta_A$公式，就可以**由M矩阵直接求出其对应的对角阵**，同理，也就可以从一个对角阵中恢复出M矩阵：

$$
\left.\left[\begin{array}{cc}\mathbf{I}&\mathbf{0}\\-\mathbf{CA}^{-1}&\mathbf{I}\end{array}\right.\right]\left[\begin{array}{cc}\mathbf{A}&\mathbf{B}\\\mathbf{C}&\mathbf{D}\end{array}\right]\left[\begin{array}{cc}\mathbf{I}&-\mathbf{A}^{-1}\mathbf{B}\\\mathbf{0}&\mathbf{I}\end{array}\right]=\left[\begin{array}{cc}\mathbf{A}&\mathbf{0}\\\mathbf{0}&\Delta_\mathbf{A}\end{array}\right] 
$$
$$\Delta_A = D-CA^{-1}B$$















