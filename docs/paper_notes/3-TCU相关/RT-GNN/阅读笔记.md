
[pdf](zotero://open-pdf/library/items/QXB4XSIT)

## 0-Abstract

图神经网络（Graph Neural Networks, GNNs）在各种基于图的学习任务中取得了显著成功，这主要得益于其能够充分利用先进的GPU。然而，GNN目前面临着在GPU中同时使用Tensor Cores（TCs）和CUDA Cores（CDs）时的诸多挑战。这些挑战因GNN中由于真实世界图的高稀疏性和不规则非零分布所导致的重复、低效和冗余的聚合操作而进一步加剧。

为了解决上述问题，我们提出了RT-GNN，这是一种基于高级TC和CD单元融合的GNN框架，通过利用邻接矩阵的特性消除这些冗余。
- 首先，提出了一种新颖的GNN表示技术——**层次嵌入图（hierarchical embedding graph, HEG）**，通过分层管理中间聚合结果，可以优雅地避免中间聚合中的冗余。
- 其次，为了解决图的固有稀疏性问题，RT-GNN通过一种新的基于<font color='red'><b>块级行乘法</b></font>的方法，根据**稀疏性**将HEG中的块（**即“tiles”**）分别分配到TC和CD上，从而使TC和CD可以并行工作。

实验结果表明，HEG在冗余消除性能方面比HAG平均加速了19.3倍，尤其是在ARXIV数据集上实现了高达72倍的加速。此外，在整体性能上，RT-GNN比最新的GNN框架（包括DGL、HAG、GNNAdvisor和TC-GNN）平均高出3.1倍，并且在任务准确性上保持甚至有所提升。

## 1-Introduction

图神经网络（Graph Neural Networks, GNNs）因其在建模和探索图结构数据方面的出色能力，越来越多地被应用于各种基于图的学习任务，例如计算机视觉和推荐系统。现有的典型GNN主要采用**递归邻居消息传递方案**，该方案分为两个阶段：<font color='red'><b>聚合</b></font>和<font color='red'><b>更新</b></font>。每个节点从其k跳邻居中聚合消息并更新自身的特征。GNN层的最终激活结果被用于下游预测任务。**稀疏操作和稠密操作交替进行，分别对应于聚合阶段的图处理和更新阶段的神经网络操作**，这使得GNN的预测计算变得困难。

将GNN扩展以有效处理大型真实图数据集仍然是一个棘手的挑战。现有的GNN框架，如Deep Graph Library (DGL)和PyTorch-Geometric (PyG)，主要构建在流行的神经网络框架之上。这些框架**通常将GNN计算分解为两个阶段：稀疏矩阵乘法（SpMM）和通用矩阵乘法（GEMM）。具体来说，SpMM主要用于图处理，而GEMM用于神经网络操作**。
📒：GNN计算操作分为两个阶段
- 图处理：使用SpMM进行处理
- 神经网络操作：使用GEMM进行处理

在GNN计算中，图处理的聚合通常是最耗时的部分。我们的实验表明，由于不规则图邻接矩阵的极度稀疏性（例如，平均稀疏性超过99.7%），这一部分甚至占据了整个GNN计算时间的72%以上。图操作涉及为每个节点聚合其所有邻居并将它们加载到内存中，这被认为是一个内存密集型操作。当两个节点的邻居之间存在显著重叠时，节点的聚合也会有显著重叠，从而导致冗余计算。

此外，现有的GNN加速库cuSPARSE在使用SpMM进行聚合时，只设计用于利用CUDA Cores (CDs)。由于邻接矩阵的高维度和稀疏性以及特征矩阵的高密度，与cuBLAS库进行的GEMM更新操作相比，这种方法耗时更多。现代GPU配备了高级硬件（如Tensor Core, TC），可以利用某些类型稀疏性的优势。但cuSPARSE的一个变体仅支持阻塞的SpMM，且要求不同行的非零块数量必须相同。现有的GNN框架大多倾向于关注传统的CUDA Core资源，而忽视了先进的Tensor Core。

为解决由于内存容量、数据传输和硬件利用率瓶颈带来的限制，许多研究已经尝试从算法和系统层面进行优化探索。

![image.png|center|1000](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20241215181557.png)

从算法的角度来看，研究人员发现，现实世界的图通常遵循幂律分布，其中同一社区内的节点往往共享共同的邻居。**在聚合过程中，大量节点之间的重叠邻居会导致大量冗余计算和内存访问，以及不必要的数据传输**。我们的实验验证了，重复和冗余计算在聚合阶段占用了84%的时间成本。如图1(b)所示，当处理节点d、e和f时，它们的共同1跳邻居a、b和c被加载和传输了三次。现有的一些方案，例如HAG和GraphACT，通过遍历具有高冗余的邻居对，利用分层聚合图来减少冗余计算。一个新的节点abc作为中间聚合结果被聚合，仅需要被加载到内存一次，如图1(c)所示。然而，HAG方法耗时较长，并且在遍历过程中可能会生成大量的中间数据（即处理过程中产生的临时数据）。其他方案，例如Betty，没有搜索有效的中间聚合结果，而是保留了所有结果，其中一些是冗余的，并受到内存限制。一些采样算法也得到了广泛研究，但由于仅在部分节点上进行训练，这些方法可能会影响模型的收敛性和准确性。在某些应用中，例如天文学中稀有快速射电暴的预测，训练需要涉及所有节点，这使得采样方法变得不可行。因此，本研究聚焦于全图训练。


从系统角度来看，研究人员也开发了多种专门的GNN方案。
- (1) 一些研究旨在充分利用GPU的计算能力。Wang等人（GNNAdvisor）和Zheng等人通过线程映射和内核优化挖掘GPU资源的潜力。这些方案主要用于调度传统CUDA Core（CD单元）的资源，而TC-GNN则仅将数据块调度到Tensor Core（TC单元），忽略了CUDA Core上的矩阵计算。这些研究**未充分考虑TC和CD在计算模式（如稠密块和稀疏块）方面的特性差异，因此在同时具备TC和CD的GPU上往往产生次优结果**。
- (2) 其他研究聚焦于稀疏矩阵乘法（如SpMM）原语，以提高计算和内存效率。GE-SpMM基于内积方法计算GNN，但在使用压缩稀疏行（CSR）格式的邻接矩阵和压缩稀疏列（CSC）格式的特征矩阵时，会产生格式转换开销，并且输入的索引匹配效率较低。I-GCN采用行级乘法，其关键计算为标量-向量乘法，但面临特征矩阵的数据局部性差和数据重用率低的问题。行级乘法中的标量-向量乘法和内积中的索引匹配并未充分利用TC单元的优势。TC单元支持固定矩阵大小的矩阵乘法原语D=A×B+C，并能够在单个GPU时钟周期内高效完成矩阵乘法。

在这项工作中，我们从更全面和协同的角度分析了上述算法和系统的问题。我们确定了聚合过程中冗余计算和数据传输，以及稀疏和稠密矩阵块与系统核心单元之间的不匹配，是训练开销的主要来源。现有方案仍然面临以下挑战：
1. **<font color='red'><b>冗余消除算法的高复杂性</b></font>**：这些算法通过遍历整个图来获得中间聚合结果，导致生成过多的中间数据。而其他研究则保存了所有的中间聚合结果，但这些结果实际上应该被有选择地检索。
2. **<font color='red'><b>缺乏利用TC和CD之间并行性的能力</b></font>**：现有方案未能充分利用TC和CD之间的并行性，导致在任何时刻TC或CD都会处于空闲状态。由于未能将TC和CD识别为独立资源，现有方案往往产生次优结果。同时，通用GPU将其warp调度置于黑箱操作中，进一步限制了优化的可能性。
3. **<font color='red'><b>现有矩阵乘法方法的局限性</b></font>**：诸如内积、外积、行级乘法和列级乘法等用于计算GNN的矩阵乘法方法，涉及索引匹配和标量-向量乘法，这些方法无法充分利用TC单元。此外，cuSPARSE库对TC单元的可扩展性较差。

为了解决上述挑战，我们通过邻接矩阵的性质构建了一种新颖的**层次嵌入图（Hierarchical Embedding Graph，HEG）**，在节点聚合阶段消除冗余。HEG比原始图具有更少的邻居节点。此外，我们利用**基于块的行级乘法来处理图的内在稀疏性**，以及混合TC和CD单元上的不同计算模式。在我们的方案中，<font color='red'><b>线程块中的活动warp可以同时使用TC和CD，从而实现TC和CD内核的融合</b></font>。总结如下，我们的主要贡献包括：
- 我们分析了GNN训练中的内存和数据传输瓶颈，并引入了一种层次嵌入图（HEG），通过分层管理中间聚合结果来消除冗余。为保证HEG的性能，我们将其线性加速设计为一个图划分问题。
- 我们提出了一种结合贪心搜索的新节点度匹配方法，基于节点的度数搜索有效的中间聚合节点，从而进一步消除中间聚合结果中的冗余。
- 我们提出了一种针对TC和CD优化的GNN计算方案Fuser，**将HEG分解为稠密块和稀疏块，并同时将其部署到TC和CD单元上执行**，而不会产生在线延迟开销。该方案能够适应动态输入。
- 我们在不同规模的图上进行了广泛实验。就冗余消除性能而言，HEG相比HAG平均加速19.3倍，相较于Betty，中间聚合所需内存减少了平均102倍。在整体性能上，RT-GNN相比DGL、HAG、GNNAdvisor和TC-GNN平均性能提升了3.1倍。


## 2-Background

### 2.1-图卷积网络

图神经网络（GNN）将深度表示推广到图数据上，旨在显式提取给定节点的高质量表示。目标节点的表示通过迭代传播邻居信息进行学习，直到达到稳定的固定点。图卷积网络（GCN）是GNN中最常见的实现之一。在每次迭代中，GCN根据第$k-1$层（$k>0$）的嵌入信息，计算第$k$层中节点$v$的特征嵌入，如下列公式(1)和(2)所示：

$$a_v^{(k)} = Aggregate(h_u^{(k-1)} \mid u \in N(v)) \tag{1}$$
$$
h_u^k = Update(a_v^{(k)}, h_u^{(k-1)}) \tag{2}
$$

其中，$h_u^{(k-1)}$表示第$k-1$层中节点$v$的邻居$N(v)$的隐藏表示，$a_v^{(k)}$表示第$k$层中的特征聚合。$h_u^0$通过特征矩阵$X_0$初始化。聚合操作通过收集第$k-1$层中节点$v$邻居的激活结果来实现。该过程也可以看作是一种特殊的乘法，其中包含稀疏邻接矩阵$A \in R^{(|V| \times |V|)}$和稠密特征矩阵$X \in R^{(|V| \times |F|)}$，其中$|V|$表示$A$中节点的数量，$|F|$表示$X$中特征的维度。

这里，邻接矩阵$A$中第$m$行的非零值表示节点$m$的邻居，且第$m$行的所有非零值会与特征矩阵$X$中对应的特征向量进行相乘，通过逐元素操作聚合节点$m$的邻居。

### 2.2-Tensor Core

现代GPU在GNN加速方面变得显著强大，它们集成了大量的CD（CUDA Cores）和TC（Tensor Cores）以提高并行性能，例如在NVIDIA Tesla A100中，包含6912个CD和432个TC。最近发布的主流GPU（如NVIDIA Volta和Ampere架构）倾向于集成不同类型的计算核心。A100的流式多处理器（Streaming Multiprocessor，SM）包括四个第三代TC，这些核心每个时钟周期可以执行256个FP16/FP32混合精度的融合乘加（FMA）操作。这一特性提高了操作数共享效率，提升了整体计算性能，并支持更强大的新数据类型。

TC被广泛用于加速通用矩阵乘法（GEMM），因为它们支持矩阵级别的计算原语$D = A \times B + C$。在最新的Ampere架构中（如Tesla A100），矩阵在块级别的尺寸分别为$A(M \times K)$、$B(K \times N)$和$C(M \times N)$，并且遵循矩阵数据类型的特定规则。矩阵$A$和$B$通常需要特定精度类型（例如Bfloat16 (BF16) 或TensorFloat-32 (TF32)），而矩阵$C$和$D$则存储为FP32格式。在TC上使用TF32进行计算时，要求$M = N = 16$且$K = 8$。与矩阵$C$和$D$相关的非Tensor操作仍然通过FP32数据路径进行处理。

对于与矩阵$A$和$B$相关的输入数据，TC会使用TF32（其数值范围与FP32相同）来替代FP32，从而提高计算速度，最终生成标准的FP32输出。换句话说，TF32作为FP32的一个高效替代方案，可以在不影响数值精度的情况下加速计算过程。最新版本的CUDA（>=11.0）在Ampere架构上进一步加速了张量运算，并且易于集成到深度学习应用的深入加速中。

## 3-Motivation

GNN结合了图处理与神经网络的执行方式，使得GNN具有更强的表达能力。在本节中，我们对工作负载的内存特性、数据传输和计算进行了分析，评估现有的冗余消除算法，并研究GPU中的TC（Tensor Core）和CD（CUDA Core）单元。基于这些分析，我们观察到现有解决方案存在计算效率低和数据重用率低的问题。我们从软件和硬件架构两个层面探究了性能限制的根本原因，并提出了一种新的协同设计方案以提升GNN的性能。

我们选取了一个广泛使用的两层GCN模型，对GNN计算的工作负载情况和运行时特性进行了深入探索。所有测试均在NVIDIA Tesla A100上进行，选取了六个具有代表性的数据集进行实验。

### 3.1-现有冗余消除算法的工作量

![image.png|center|800](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20241217083853.png)

从算法角度来看，我们可以对聚合和数据传输的工作负载做出以下两点观察：

**观察1**
在高度不规则的稀疏图中（稀疏度超过99.7%），聚合操作是耗时的主要原因，节点之间存在大量重叠邻居，导致大量冗余计算。图2(a)展示了一个训练周期中数据传输、聚合和其他操作的时间分布。实验结果表明，在训练周期中，聚合阶段的计算和数据传输操作平均占总时间的72%以上，尤其是数据传输，由于稀疏图的不规则数据加载，甚至占到了67%的时间。冗余计算的成本构成了聚合操作的84%。值得注意的是，在计算过程中，某些图数据集相较于原始图的规模，被重复加载了四次，从而产生冗余。

**观察2**
现有的冗余消除算法具有较高的计算复杂度，会生成大量中间数据。例如，**HAG**经过重构和测试后，图2(b)显示了冗余消除过程中生成的中间数据的峰值内存使用量。HAG会为每个节点遍历节点对，并通过**UNORDERED_MAP**哈希结构逐一累积相同节点对的冗余。不同节点对的冗余数据都存储在该结构中，导致在大规模数据集上生成大量中间数据，并引发冲突。HAG在**PRODUCTS**和**REDDIT**数据集上出现了内存溢出（OOM）问题，过高的内存使用量使HAG无法处理大规模图数据。

此外，其他算法（如**Betty**）会存储所有检测到的中间聚合结果，而这些结果本应被有选择地检索。


### 3.2-异构核对 GNN 矩阵处理的挑战

从架构角度来看，我们对GNN训练过程中的并发性有以下观察：

![image.png|center|800](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20241217084617.png)

**观察3**：现有方案主要针对传统CUDA Core (CD单元) 进行调度，当应用于配备异构核心（Tensor Core (TC) 和 CUDA Core）的GPU时，往往会产生次优结果。例如，DGL仅使用CD单元通过cuSPARSE进行计算和数据传输。而TC-GNN则将GNN计算中的矩阵乘法完全部署在TC单元上，CD单元仅用于数据传输和其他操作。图3显示了在TC-GNN运行GCN模型时，两种单元在Streaming Multiprocessor (SM) 上的活动时间线。由于**现有解决方案未将TC和CD视为独立资源，无法同时高效调度两个单元，导致任意时刻要么TC单元空闲，要么CD单元空闲**。此外，当两类单元都处于空闲状态时，可能是由于内核启动开销和事件记录与内核执行之间的上下文切换所致。

为了充分利用潜在的并发性，作者探索了几种架构加速的可行方案。通过对不同调度策略的实验发现，<font color='red'><b>如果线程块中的不同活跃warp同时为两种类型的单元（TC和CD）提供服务，TC和CD便可以实现并行执行</b></font>。**线程块间的warp分歧不会导致不必要的计算，因为每个warp具有确定性的执行路径。因此，这为TC和CD的融合提供了机会，可以通过同时分配硬件资源，在warp之间重叠独立数据块来实现并行**。然而，TC和CD直接融合时存在资源竞争问题，导致效率降低。因此，作者在内存管理的基础上进一步探索了这两类单元的最大并行性，以提升数据重用率。

## 4-RT-GNN Design

基于上述观察，我们提出了一个名为RT-GNN的GNN框架，该框架通过融合先进的Tensor Core（TC）和CUDA Core（CD）单元，利用邻接矩阵的特性消除聚合过程中的冗余计算。

我们首先提出了层次嵌入图（HEG）来分层管理中间聚合结果，这一方法能够完美替代传统的冗余消除过程。此外，通过结合贪心搜索和度匹配的方法，进一步消除冗余的中间聚合结果。除此之外，我们提出了一种基于块的行级乘法方法，以及针对不同计算模式的TC与CD融合方案，以为GNN计算提供高效支持。

- 提出层次嵌入图来分层管理中间聚合结果
- 结合贪心搜索和度匹配方法，进一步消除冗余的中间聚合结果
- 基于块的行级乘法方法，提出不同计算模式的TC和CD融合方案

### 4.1-HEG表示



### 4.2-TC和CD定制并行GNN计算

为了在HEG中利用异构核心（Tensor Cores 和 CUDA Cores，简称TC和CD）的数据局部性和潜在并行性，我们提出了一种基于**块级行乘法**的方法，以解决观察3中指出的问题。我们方案的基本构建单元是**图块**，即将图划分为数据块，也称为tiles。这种基于块的方法有两个主要优势：
- (1) 减轻了因过多内存占用带来的压力；
- (2) 通过在Tensor Core和CUDA Core（TC和CD）上实现块级并行，充分挖掘并行计算潜力。

![image.png|center|800](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20241217091949.png)

图的稀疏性通常对最终结果产生负面影响，这启发我们首先进行以下改进：
- **轻量级图重排**：我们利用图重排来提高节点局部性，如图6所示，这仅对现有系统进行最小化修改。轻量级图重排有两个好处：
	- (1) **数据局部性得到了改善**。稠密和稀疏块能够促进TC和CD单元的基于块的计算，从而显著提高并行性能。
	- (2) **图块数量得到减少**。我们使用启发式**度排序**方法，对邻接矩阵中的节点按入度进行排序。这样，非零值显示出更高的聚集性特征（见图6(b)）。入度高的节点趋向于移动到左侧，右侧则留下更多空行，适用于稀疏块划分。因此，加载的图块总数从四个减少到三个，如图6(b)所示。
- **针对TC和CD优化的乘法**：我们采用**基于块的行乘法**，用于邻接矩阵$A$和特征矩阵$X$的乘法运算，并在其中融合了Tensor Core (TC) 和CUDA Core (CD) 的内核执行。矩阵$A$和$X$被划分并约束为更小的块。在我们的方法中，通过合并具有相似邻居的相邻节点的工作负载，加载的稀疏特征块可以被重用。我们利用HEG中的稀疏趋势（从左到右逐渐变得更加稀疏），**方便地将不同类型的计算模式（稠密或稀疏）与不同类型的计算核心（TC或CD）匹配，以充分发挥各自的优势**。

在**第一阶段**，如图7(b)所示，数据被加载。邻接矩阵$A$的稠密块和稀疏块可以通过分别从$A$的左右两侧扫描对应的行，同时并行地部署到Tensor Core（TC）和CUDA Core（CD）。与此同时，特征矩阵$X$中两个窗口的两个块（绿色块）被加载到共享内存中。此外，我们根据块级的warp组织方式自定义共享内存布局，以减少对全局内存的不必要访问。映射到同一tile的$X$中的块按顺序存储，从而通过基于tile的内存访问提供高空间局部性。

在**第二阶段**，进行数据计算。矩阵$A$中的tile与$X$中对应的tile相乘，其中$X$矩阵的行索引由$A$矩阵非零值的列索引决定。TC单元从左到右处理$A$中的稠密块，而CD单元同时从右到左处理非零的稀疏块。这种方式提高了指令级并行性。相比之下，TC-GNN仅在一行中将tile分配给TC单元进行计算，如图7(a)所示，这会产生大量内存事务，且无法超越TC和CD同时处理tile的效率。在TC-GNN中，当TC单元计算tile时，CD单元处于空闲状态。

TC和CD上的块级并行促进了训练过程中的负载平衡，有效缓解了由于矩阵稀疏性导致的不平衡问题。基于块级行乘法方法的主要优势如下：
1. **更快的计算速度**：我们的方案利用了先进的TC和CD硬件单元，在TC和CD上并行进行tile乘法运算。相比之下，传统的行级乘法仅能利用CD单元进行标量-向量乘法。
2. **高数据重用率和低内存需求**：合并相邻节点的计算负载可以提高数据局部性。此外，由于图7(b)中的两个输出窗口同时计算，输出矩阵 的缓冲区大小可以减少到两个窗口。而现有方法（如外积法）通常需要将整个输出矩阵存储在内存中。
3. **减少同步开销**：我们的方案允许流式多处理器（SM）异步计算输出矩阵的不同tile，避免频繁同步读写操作。

### 4.3-基于PTB的柔性融合

现有方案无法有效利用Tensor Core（TC）和CUDA Core（CD）之间的并行性，<font color='red'><b>导致在任何时刻TC或CD总有一方处于空闲状态</b></font>。这些方案未能将TC和CD识别为独立资源，因此往往导致次优的结果。我们提出了一种**Fuser**异构核融合方案，该方案能够并行融合并调度TC和CD单元。每个窗口通过<font color='red'><b>持久线程块（Persistent Thread Block, PTB）</b></font>分配给一个流式多处理器（SM），在PTB中，每个线程块被视为一个工作单元。使用PTB时，每个持久线程块被分配相应的任务，这些任务对应于原始线程块。PTB会始终保持SM处于忙碌状态，直到分配的任务全部完成才退出。

通过对不同调度方案进行多次测试，我们发现，<font color='red'><b>如果线程块中的不同warp同时在Tensor Core（TC）和CUDA Core（CD）单元上执行任务，这两种核心可以实现并行化</b></font>。**在同一个线程块中，多个warp可以并行激活。warp之间的分歧不会引发不必要的计算，因为每个warp都有确定的执行路径**。这为优化提供了机会，通过合理地分配硬件资源并将独立的数据块分配给多个warp，从而实现重叠计算。

基于持久线程块（PTB）的简单方案将TC和CD单元以1:1的比例进行融合，但这可能会降低TC单元的性能。**实际上，每个TC在流式多处理器（SM）中每个时钟周期可以完成256次融合乘加（FMA）操作，而每个CD每个时钟周期只能执行一个标量乘法操作，显然不适合密集计算**。因此，我们提出了一种**灵活融合比**的方案，以增强Fuser。**根据TC和CD的处理速度，将图块按灵活比例分配到TC和CD单元上。这个灵活比例由TC上第一个右侧图块与CD上第一个左侧图块的执行时间比例决定**。

![image.png|center|800](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20241217101620.png)

在实际应用中，邻接矩阵的图块会从双端队列中动态地调度到TC和CD单元上，如图8所示。在GPU的定制共享内存中，通过一个数组来模拟双端队列的实现，并一次性将所有数据加载到队列中。这是内核实现的一部分。数组中warp所需数据的位置由对应warp的索引编号决定。TC单元从较小的索引到较大的索引获取数据，而CD单元则相反。数据不需要再次入队。

warp会根据灵活融合比被分配到TC或CD分支。这里，**分支**是具有相同确定执行路径的一组warp。<font color='red'><b>TC和CD的分支划分基于灵活融合比</b></font>。例如，如果窗口中的TC与CD的灵活融合比为2:1，那么TC分支的数量将是CD分支的两倍，TC和CD分支的总数为3。**为了更好地组织这些分支，我们确保每个分支中的warp数量相同**。

为避免数组访问冲突，我们为每个分支分配窗口中对应的索引范围。索引范围的数量由TC和CD分支总数确定，而索引范围的长度则由窗口长度除以分支数量得到。索引范围的数量设置为3，且彼此之间不重叠。每个分支在TC或CD上以相同的索引范围长度和warp数量进行处理，所需时间几乎相同。因此，所有分支可以并行完成图块的计算。最后，TC单元会被分配去处理那些位于已定义索引范围之外的剩余图块。由于不同分支之间的时间差异很小，我们仅需要进行warp级同步，从而实现跨warp的显式同步，具体细节在第4.5节中描述。

关键步骤是从队列中将足够多的**稠密块**分配给Tensor Cores（TCs），使其尽可能满载工作，同时将合适的**稀疏块**分配给CUDA Cores（CDs），让它们与TCs协同工作。我们优先使用TC单元以获得更高的吞吐量，因为TC在矩阵乘法方面比CD更强大。**Fuser** 最大限度地利用了TC和CD的并行能力，使两类单元能够同时完成各自的计算任务。与现有方法相比，Fuser表现更优，因为在这些方法中，TC或CD在任何时刻都会出现空闲状态。

此外，我们基于资源估算（详见第4.4节），为单个流式多处理器（SM）分配了足够的线程块。需要注意的是，即使在自适应Fuser中，仍然存在隐性的资源争用问题。此外，Fuser能够适应动态输入，在有限资源下最大限度地挖掘出各单元的并行潜力。

### 4.4-成本函数与内存感知调度策略

我们引入了一个代价函数$f$来表征GNN模型的训练开销。该代价函数用于估算特定窗口中所有节点的聚合和更新操作所消耗的资源。最初，RT-GNN通过代价函数估算窗口的工作负载，然后执行**面向内存的调度**，以最大化流式多处理器（SM）的占用率，如图8所示。RT-GNN能够动态分配工作负载，并解决多个SM单元之间的负载不平衡问题。

**并发线程块**的核心思想是<font color='red'><b>保持大量的warp处于激活状态，以隐藏由于块乘法引起的延迟</b></font>。共享内存是限制线程块并行度的主要因素。此外，SM中的寄存器也是GPU上稀缺的资源。在本研究中，我们通过使用`_launch_bounds_()` 将无法存放在寄存器中的数据放入本地内存，以提高SM的占用率。

### 4.5-同步

我们注意到输出矩阵在写入前读取时会发生**竞争条件**，这需要适当的线程同步。一般来说，现有矩阵乘法内核在完成一个块的计算后会调用 `__syncthreads()` 来同步所有线程。然而，调用 `__syncthreads()` 可能会导致**死锁**、性能下降和结果错误等问题。因此，我们利用基于<font color='red'><b>底层PTX代码 bar.sync</b></font> 的**批量同步接口**，该接口作为块内的**warp级别屏障**。我们仅在同一分支完成计算时显式进行**跨warp同步**。由于在跨warp中没有两个线程写入相同的输出区域，因此在处理分支内的每个warp之后不需要进行同步。
![image.png|center|800](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20241217103349.png)
如图9所示，一批在Tensor Core (TC) 和CUDA Core (CD) 上以2:1速度比完成计算的warp，仅在每个单元上同步一次。


### 4.6-实现

现有的框架（如PyTorch和TensorFlow）通常<font color='red'><b>将图的拓扑结构转换为稀疏邻接矩阵来实现GNN模型</b></font>。基于PyTorch框架，我们聚焦于聚合阶段，并通过提出的TC与CD融合方案，实现了冗余消除和基于块级行的稀疏矩阵乘法，以加速不规则的聚合计算。我们应用以下算法模块，为GNN计算提供高效支持：
- `_Part_Parallel_` 会将一个GNN图 $G$ 自动转换为等价的 HEG $G’$，并获取公共邻居以减少冗余计算。
- `_Fuser_` 会自动编译优化后的核函数，将TC与CD融合。
- `_RT-GNN_aggregate_` 将 HEG $G’$ 和节点特征作为输入，计算所有节点的前向传播值。前向传播会自动调用优化后的核函数 `_Fuser_`，无需用户干预。
- `_RT-GNN_aggregate_grad_` 通过编译后的优化核函数 _Fuser_ 计算梯度，以进行反向传播并更新模型。
我们的实现对现有的GNN编程模型进行了最小的改动。我们使用了一种聚合和更新的编程模型，这是GAS（Gather-Apply-Scatter）编程模型的一个变体。这种变体被广泛应用于GNN模型，如DGL、HAG、NeuGraph等。当应用上述改进后，只需修改少量代码，即可使GNN应用程序从所有RT-GNN优化中获益。

## 5-Evaluation







## 6-Related work







## 7-Conclusion

在本研究中，我们提出了**RT-GNN**，一种结合冗余消除的基于**块级行乘法**的方法。首先，我们构建了一种新颖的图表示方法**HEG**，通过贪心搜索与新的度匹配方法相结合，有效地消除冗余。其次，为了在训练和推理过程中提高数据局部性和数据重用率，我们提出了**基于块级行乘法**的方法，通过内核融合实现Tensor Core (TC) 和 CUDA Core (CD) 单元在不同计算范式下的并行执行。此外，与PyTorch框架的集成进一步实现了端到端的高可编程GNN计算。大量实验表明，RT-GNN在各种GNN模型和数据集上，相较于DGL、HAG、GNNAdvisor和TC-GNN等最先进框架表现出优越的性能，并突显了其性能优势。

在未来的工作中，我们提出的HEG可以结合**运行时训练的分层流水线机制**部署到GPU上，并通过**异步流水线**和**资源感知的动态Tensor Core与CUDA Core内核融合**进行优化，从而加速模型的并行计算。








