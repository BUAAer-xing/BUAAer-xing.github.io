# 阅读笔记

## 文章笔记提前梳理

### 背景

1. **稀疏矩阵-向量乘法(SpMV)的重要性**：SpMV是一种在许多应用场景中至关重要的计算内核，如气候模拟、计算机图形学、分子动力学、数据分析、机器学习和深度学习等。这些领域对稀疏矩阵的高效计算提出了高要求。
2. **现有解决方案的局限性**：在过去的几十年中，已经提出了许多稀疏矩阵格式和实现方法来压缩内存存储并加速SpMV性能。然而，这些方法<font color='red'><b>通常是基于人工设计的特定格式和优化方法，无法应对日益增长的稀疏矩阵种类和复杂性</b></font>。此外，<font color='red'><b>现有的自动调优器也存在局限性，只能在有限的人工设计格式中进行选择，未能充分发掘潜在的高性能格式</b></font>。
3. **高性能需求**：尽管已经有许多研究致力于提高SpMV性能，但现有的技术在面对高度不规则的稀疏数据时仍然无法达到预期的高性能。
4. **应对多样化的稀疏矩阵模式**：人工设计的矩阵格式往往只能处理特定的矩阵模式，对未覆盖的模式表现不佳。随着实际应用中稀疏数据和模式的不断涌现，需要新的格式和内核实现来应对未来的需求。
5. **处理不规则稀疏性**：<font color='red'><b>不规则性是当前SpMV程序设计中最大的挑战之一</b></font>，**不规则的行长度分布和位置分布会导致并行性和内存访问效率的巨大挑战**。现有的许多格式无法很好地处理不规则稀疏性，导致性能低下。
6. **突破现有自动调优器的局限性**：**现有的自动调优器仅能在有限的人工设计格式和实现中进行选择，无法探索潜在的高性能组合**。AlphaSparse旨在超越这种局限，通过直接从输入稀疏矩阵的稀疏性模式和硬件架构中生成新的机器设计格式和SpMV内核实现，最大化性能。 

笔记📒：截止到目前，已经提出许多稀疏矩阵格式和实现方法来压缩存储并加速SpMV性能，然而，这些提出的方法通常是基于人工设计的特定格式和优化方法，无法应对日益增长的稀疏矩阵种类和复杂性。而且，现有的自动调优器也存在局限性，只能在有限的人工设计格式中进行选择，无法充分发掘潜在的高性能格式。随着实际应用中稀疏数据和格式的不断涌现，需要新的格式和内核实现来应对未来的需求。

好句子🍊：不规则性是当前SpMV程序设计中最大的挑战之一，不规则的行长度分布和位置分布会导致并行性和内存访问效率的巨大挑战。

### 解决措施

开发一个名为AlphaSparse的系统，该系统通过<font color='red'><b>自动生成稀疏矩阵格式和SpMV内核实现，以应对现有方法的局限性</b></font>。AlphaSparse包括以下几个主要组件和方法：
1. **设计器 (Designer)**：
   - **操作符图 (Operator Graph)**：作者提出了一种新的模型，称为操作符图，模拟SpMV设计的哲学，探索更大的设计空间。操作符图由连接任意数量的操作符组成，每个操作符表示一种设计策略，能够在三维设计空间内同时“移动”（格式、内核、参数）。
   - **操作符**：设计器将现有的格式和内核实现细化为多个设计策略，称为操作符，这些操作符涵盖了整个SpMV程序的设计过程。
2. **格式和内核生成器 (Format & Kernel Generator)**：
   - **矩阵元数据集 (Matrix Metadata Set)**：包括当前矩阵状态的多视角描述，记录矩阵如何被转换。操作符图中的操作符依次修改矩阵元数据集，以生成相应的格式和内核实现。
   - **内核生成器 (Kernel Builder)**：内核生成器基于模板生成内核，包括内核骨架和内核片段。内核片段是操作符在实现阶段的具体表示，通过组合不同的内核片段，生成高性能的SpMV内核代码。
3. **搜索引擎 (Search Engine)**：
   - **操作符图搜索**：搜索引擎通过枚举操作符图和选择最佳组合来驱动AlphaSparse。搜索策略包括三个步骤：1) 枚举图结构，2) 粗粒度网格搜索节点（操作符）参数，3) 通过机器学习模型插值到细粒度网格，以减少直接运行SpMV程序的开销。
   - **剪枝策略**：为了减少搜索空间，搜索引擎采用剪枝策略，根据输入矩阵的稀疏性模式和已有的操作符图，对不必要的操作符进行剪枝。
4. **优化器 (Optimizer)**：
   - **模型驱动格式压缩 (Model-Driven Format Compression)**：优化器通过将数组类型数据转换为模型并用计算代替内存访问，减少内存访问次数，从而优化内核性能。
通过以上组件和方法，<font color='red'><b>AlphaSparse能够自动生成高性能的SpMV程序，超越现有人工设计格式和传统自动调优器的性能限制</b></font>。文章中还提供了广泛的实验评估，证明了AlphaSparse在处理843个稀疏矩阵时，平均性能提升了3.2倍，最大提升了22.2倍，显著优于五种最先进的人工格式和传统自动调优器。

笔记📒：本文提出了AlphaSparse系统，**通过自动生成稀疏矩阵格式和SpMV内核实现，以应对现有方法的局限性**。AlphaSparse由设计器、格式和内核生成器、搜索引擎和优化器组成。设计器使用操作符图模型，将格式和内核实现细化为多个设计策略。格式和内核生成器通过矩阵元数据集和内核生成器生成高性能的SpMV内核代码。搜索引擎通过多级搜索策略和剪枝策略优化操作符图，并利用机器学习模型提高搜索效率。优化器采用模型驱动格式压缩，减少内存访问次数，从而提升内核性能。

### 与现有工作的关系

为之后论文的发表提供文献支持，同时观察该idea能否作为论文中的组件进行应用。

## 0-Abstract

稀疏矩阵-向量乘法（SpMV）是许多应用场景中的重要计算内核。已经提出了几十种稀疏矩阵格式和实现方法来压缩内存存储并加速SpMV性能。我们开发了AlphaSparse，它是<font color='red'><b>所有现有工作的一种超集</b></font>，超越了人工设计格式和实现的范围。<font color='red'><b>AlphaSparse完全基于输入稀疏模式和硬件架构的知识，自动创建新的机器设计格式和SpMV内核实现</b></font>。

基于我们提出的**表达SpMV格式和内核设计路径的操作符图**（Operator Graph），AlphaSparse由三个主要组件组成：设计器（Designer）、格式和内核生成器（Format & Kernel Generator）以及搜索引擎（Search Engine）。<font color='red'><b>它以任意稀疏矩阵作为输入，输出高性能的机器设计格式和SpMV实现</b></font>。

通过对来自SuiteSparse矩阵集合的843个矩阵进行广泛评估，AlphaSparse相比五种最先进的人工格式平均实现了3.2倍的性能提升，相比最新的传统自动调优方法平均提升了1.5倍（最高可达2.7倍）。

## 1-Introduction

稀疏矩阵-向量乘法（SpMV，y=Ax）是许多领域中的重要计算内核之一，例如气候模拟、计算机图形学、分子动力学、数据分析、机器学习和深度学习等。在过去的几十年中，已经进行了许多努力来通过提出**稀疏矩阵格式**、利用**各种性能优化方法**和**自动性能调优**（auto-tuning）来改进SpMV性能。

已经提出了几十种稀疏矩阵格式，以在**多核CPU**、**图形处理单元（GPU）**、**Intel Xeon Phi加速器**和**现场可编程门阵列**（FPGA）等现代架构上高效地压缩稀疏矩阵的内存存储。这些格式的设计目标多种多样：<font color='red'><b>减少内存访问</b></font>、<font color='red'><b>改善负载平衡</b></font>、<font color='red'><b>减少GPU线程发散</b></font>等。它们只存储非零元素，而忽略占据稀疏矩阵大部分的零元素。我们将稀疏矩阵格式分为三类：根格式、派生格式和混合格式。

通常认为有四种基本格式或根格式，它们是：
- 坐标格式（COO）
- 压缩稀疏行格式（CSR）
- ELLPACK格式（ELL）
- 对角线格式（DIA）

为了处理更不规则的矩阵、更好的内存压缩或更高性能的稀疏内核，已经提出了许多派生格式。本文**将派生格式定义为基于仅一个根格式手动设计的格式**，例如基于COO的块坐标格式（BCOO）、基于CSR的CSR5格式、基于ELL的切片ELLPACK格式（SELL）等。除了根格式和派生格式，**混合格式灵活地使用多种格式来处理稀疏矩阵的不同部分**。它们可以是根格式和派生格式的混合，例如HYBrid（HYB）、COCKTAIL和扩展压缩稀疏格式（CSX）。

由于稀疏模式的多样性以及输入矩阵特征、架构特性与SpMV性能之间的密切关联，找到一种通用的格式或优化方法是不现实的。因此，已经设计了如SMAT、clSpMV和Zhao等人的<font color='red'><b>SpMV自动调优器</b></font>，**从一组候选人工格式中为给定矩阵选择最合适的格式**。

尽管上述研究已经做出了努力，这个经典但顽固的内核仍然远未达到其可实现的性能，特别是对于高度不规则的稀疏数据。观察到在现有的最先进研究中，有三个问题阻碍了SpMV实现更高的性能。
- 问题1：**有限的人工实践难以应对不断增长的稀疏矩阵数量**。
	- 一般来说，一种矩阵格式只能处理特定的矩阵模式，并且在这种矩阵上表现良好。因此，不在该格式覆盖范围内的模式会导致性能低下。根据我们在SuiteSparse矩阵集合中的实验，主流格式ELL、HYB、ACSR和CSR-Adaptive之间的性能最大值与最小值相差约10倍。
	- 从另一个角度来看，SuiteSparse矩阵集合已逐渐收集了来自91个领域的2893个矩阵。随着实际问题中领域和数据的不断涌现，我们很可能会面对新的稀疏数据和模式，这些都需要新的格式和内核实现。不断为新出现的矩阵设计新的格式对研究人员来说既不高效，也不现实，甚至是不可能的。
- 问题2：**不规则稀疏性的挑战**。
	- <font color='red'><b>不规则性几乎是当前SpMV程序设计中最大的挑战</b></font>。它带来了行长度和行位置的多样化分布，**导致高效并行化和内存访问变得极其困难**。
	- 在本文中，**将行长度方差超过100的稀疏矩阵定义为不规则矩阵**，根据最近的格式研究目标矩阵。不规则矩阵在SuiteSparse矩阵集合中占比超过35%。由于**高度冗余计算**、**不平衡负载**、**内存访问热点**等原因，<font color='red'><b>一般的稀疏矩阵格式无法很好地适应不规则稀疏性</b></font>。尽管一些新格式（如CSR5、ACSR和Merge-based CSR）已经被提出，特别是针对不规则稀疏性，但它们的适用性仍然有限（在评估中仅关注10-20个矩阵）。
- 问题3：**现有自动调优器的局限性**。
	- <font color='red'><b>现有的自动调优器被建模为粗粒度的格式选择器，并且受限于人类经验和实现</b></font>。在图1a中描绘了一小部分人工格式和SpMV实现（分别用蓝色圆圈和方块表示）。每种格式都有一个或多个耦合的内核实现。
	- ![image.png|center|1000](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20240526200154.png)
	- (a)传统自动调谐器的搜索空间。(b)原始设计空间中格式选择自动调谐器和 AlphaSparse 的搜索方法。
	- **传统的自动调优器本质上是选择一种格式-内核组合**（用实心蓝线表示），而<font color='green'><b>其他潜在存在但人为未发现的格式、内核实现及其之间的连接（用红色显示的情况1-3）则被忽略</b></font>。以情况1为例，它使用现有的行分组CSR格式，但结合了CSR5的线程级归约和行分组CSR的全局内存归约进行新的实现。这些被忽略的情况使自动调优器错失了潜在的性能提升机会。更糟糕的是，不规则稀疏性的复杂性放大了格式选择器的这一缺点。

AlphaSparse通过实现一个最终目标来解决这些问题：<font color='red'><b>创建超越人类实践范围且性能优于人工格式和传统自动调优器的机器设计SpMV程序</b></font>。

本文通过直接**在SpMV程序的原始设计空间中搜索**来实现这一目标，该设计空间包含三个维度：
- 1）**格式**，即数据在内存中的布局；
- 2）**内核**，即数据的计算方式；
- 3）**参数**，即前两个维度的定量细节（如图1b所示）。（这里的参数具体指的是什么参数？）

设计空间的每个位置都代表一个SpMV程序。
- 蓝色路径展示了传统自动调优器的选择策略，这些调优器只能在三个方向中的任意一个方向上并行移动。
- 红色路径：本文的选择策略。
	- 相比之下，AlphaSparse提出了一种新的模型，称为**操作符图**（Operator Graph），它模拟SpMV的设计理念，以利用更大的空间。
	- **操作符图**是通过连接任意数量的操作符到设计空间特定位置的“路径”（详见第IV节）。
	- **操作符**是设计空间中的一个向量，**代表SpMV程序的设计策略**，能够在三个维度中同时“移动”。
	- 这种更灵活和集成的模型使AlphaSparse能够实现现有人类工作无法达到的设计，并获得更多的高性能机会。

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20240526203145.png)

表格I从稀疏性、不规则性和创造性三个角度比较了AlphaSparse与主流相关工作的区别。与人工格式设计和传统SpMV自动调优器相比，AlphaSparse在创造性和不规则性方面展现了其新颖性。它是第一个创建全新机器设计格式及其SpMV实现以追求高性能的工作。一些编译器似乎更灵活，尤其是TACO。然而，其通用的中间表示（IR）隐藏了算法和硬件架构的细节，仅涵盖了对一般稀疏问题的基本优化，错失了许多优化机会。此外，TACO仍然通过利用“层级格式”概念来探索有限的人工格式，这与格式选择器相同。

然而，构建智能AlphaSparse需要克服三个挑战。
- 第一个是**更大的搜索空间**。
	- 设A为所有已知人工格式的数量，并假设每种格式提供一种独特的格式或内核设计策略。仅比较搜索空间的格式-内核子集，传统自动调优的大小为O(A)，而在包含p个操作符的操作符图中，AlphaSparse的大小理论上为$O(A^p)$。
- 第二个挑战是**集成建模**。
	- 从大量现有工作中提取SpMV的设计策略并将其表达为统一的中间表示（IR）并非易事。
- 最后一个挑战是**将原始设计空间中的位置投影到三维空间中**
	- 以获得相应的SpMV程序。

AlphaSparse有三个主要组件来解决这些挑战：**设计器（Designer）、格式和内核生成器（Format & Kernel Generator）以及搜索引擎（Search Engine）**，以实现设计空间的表达、投影和探索。

设计器和格式与内核生成器将操作符图作为输入，生成具有相应内核实现的格式。搜索引擎旨在找到高性能的操作符图。在搜索过程中，可以通过直接运行生成的SpMV程序来获得与操作符图对应的SpMV性能。

本文用超过11万行的C++代码实现了AlphaSparse，这些代码将被发布。尽管本文仅关注SpMV，但AlphaSparse的方法甚至可以通过定义新的对应操作符和后端来适应更多稀疏问题。

本文的主要贡献总结如下：
- 本文首先展示了**现有工作中被忽视的潜在高性能SpMV程序**，并论证了AlphaSparse的必要性和可行性基础（第二节）。
- 本文开发了AlphaSparse，它**通过输入Matrix Market文件并输出由机器生成的高性能SpMV代码**，使用起来非常方便。
	- AlphaSparse可以被视为高性能稀疏问题领域的AlphaFold，相当于从头预测蛋白质结构，而传统的自动调优器则对应于蛋白质结构预测中的传统模板方法（第三节）。
- 设计空间通过一种新提出的基于图的建模方法——<font color='red'><b>操作符图</b></font>（第四节）来表达；**通过格式和内核生成器进行投影，生成压缩的数据表示和高性能的实现**（第五节）；并**在AlphaSparse中通过三级搜索和剪枝策略进行探索**（第六节）。
- 我们在SuiteSparse矩阵集合中的843个大型矩阵上评估了AlphaSparse。
	- AlphaSparse相比五种最先进的人类设计格式，最多可以将SpMV性能提高22.2倍（平均提高3.2倍）。
	- 将AlphaSparse与最新的格式选择器实现进行比较，AlphaSparse的性能提升最多达到2.7倍（平均1.5倍）（第七节）。

## 2-Motivation

通过两个观察，分别说明了该方法的必要性和可行性。

### 2.1-观察 1

<font color='green'><b>人工格式及其稀疏内核算法受到人类经验和狭窄搜索空间的限制，未能发挥出更高的性能潜力</b></font>。新提出的人工稀疏矩阵格式和自动调优器涵盖了越来越多的稀疏模式。然而，人类实践忽略了大量潜在的格式和内核。
![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20240529225331.png)
<center> <font face='华文宋体' size='4'> 图 2 AlphaSparse 在矩阵2D27628bjtcai 的格式和内核空间中发现了混合设计 </font> </center>
如图2所示，在SuiteSparse矩阵集合中的矩阵2D_27628_bjtcai上，CSR-Adaptive、行分组CSR和SELL分别达到了39 GFLOPS、58 GFLOPS和61 GFLOPS。通过结合行分组CSR的块策略与CSR-Adaptive的归约策略，混合格式的性能提升至75 GFLOPS。同样，**通过混合所有这些源格式的格式和内核**，性能可以进一步提升至95 GFLOPS。

### 2.2-观察2

<font color='green'><b>稀疏格式通过共同步骤从源矩阵转换而来，使得通过这些共同步骤的更多组合创建新格式变得可行</b></font>。这一观察结果已经被其他工作所证实 ，尽管他们强调了现有人工格式之间的转换。通常，当设计一种新的人工格式时，转换程序也会从原矩阵中提供。
![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20240606205908.png)
<center> <font face='华文宋体' size='4'> 图 3 ：将微小稀疏矩阵转换为 CSR、 COO 和 ELL 的步骤 </font> </center>
本文以三种根格式的转换为例，如图3所示。在开始时，通过忽略所有的零，原始的输入矩阵被压缩。通过分块每一行中的矩阵，可以获得 CSR 格式。此外，通过在每个块中进一步填充或在每个列中阻塞，可以生成 ELL 或 COO。这四个步骤通常存在于其他格式转换中。因此，通过采取更常见的转换步骤来自动生成甚至创建格式是可行的。

## 3-Overview
![image.png|center|1000](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20240526200154.png)
<center> <font face='华文宋体' size='4'> 图 1 </font> </center>
AlphaSparse 提出了一种集成模型——算子图(Operator Graph)。运算符图描述和探讨了原点的三维设计空间的格式，内核和参数同时与运算符(如图1所示)。**它提供了一个细致的搜索来处理与 SpMV 性能高度相关的稀疏模式所带来的复杂性**。算子统一地表达内核和格式设计的信息，包括它们的参数配置。通过对算子图的转换，不仅可以生成高性能的算子图，而且可以生成新的机器设计的格式和内核。
![image.png|center|1000](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20240606212608.png)
<center> <font face='华文宋体' size='4'> 图 4 ：AlphaSparse 概述 </font> </center>
AlphaSparse由<font color='red'><b>搜索引擎</b></font>（第VI节）、<font color='red'><b>设计器</b></font>（第IV节）和<font color='red'><b>格式与内核生成器</b></font>（第V节）组成。如图4所示。
- **搜索引擎**首先通过生成图结构和相应的参数来枚举运算符图，在给定的搜索策略下。枚举的运算符图将被发送到设计器那里。
- **设计器**按顺序执行这些运算符，以修改矩阵元数据集，其中包括矩阵状态的所有细节。
- 最后，**格式与内核生成器**根据运算符图和矩阵元数据集**产生内核和格式**，并进行多项优化。
对于特定结构的运算符图，AlphaSparse首先通过直接在粗粒度网格上对每个参数组合的SpMV程序进行性能评估。为了进一步实现低开销参数空间中的详细搜索，AlphaSparse使用<font color='red'><b>轻量级机器学习（ML）成本模型</b></font>将参数插值到一个细粒度网格中。直到基于模拟退火满足停止条件时，搜索过程停止并输出其找到的最佳SpMV代码。

AlphaSparse已经提供了高开箱即用性能，并且对顶级用户易于使用。**用户只需输入一个稀疏矩阵的Matrix Market文件，AlphaSparse将输出以特定格式存储的矩阵和核实现**。基本上，除了传统的自动调谐器外，AlphaSparse作为算法研究人员在开发新的SpMV格式和核心时的替代品迈出了重要一步。通常，这种算法工作不仅高度依赖个人灵感，而且需要花费数月甚至数年时间。AlphaSparse只需几小时就能大幅胜过几乎所有人工设计。从这个角度看，AlphaSparse不是传统意义上的在线性能调谐器，而是SpMV算法研究工具或极其优化库生成器，它将焦点从整个算法缩小到特定操作符(s)。生成的代码可以直接在实际应用中调用。本文中关于该论文成果描述展示了其用途。

## 4-Designer（设计器）

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20240606213522.png)
设计器维护操作图，这是AlphaSparse的关键数据结构。本文率先将现有的格式和内核实现分解为更细的粒度设计策略，并使用它们对SpMV程序进行建模（如表2所示）。作为算子的组合，算子图打开了更广阔的格式和内核设计集成空间。与现有的格式选择器相比，AlphaSparse在性能调优方面具有更高的灵活性，从而在更大的概率下获得优于SpMV代码的性能。

### 4-1 操作符
![image.png|center|1000](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20240606214122.png)
- **Converting 转换阶段**
	- ROW(COL)\_DIV 操作：将矩阵划分为行或列
	- SORT操作：按照每行非零元素的数量对行进行降序排列
	- SORT_SUB操作：在子矩阵中按照每行非零元素的数量对行进行降序排列
	- BIN操作：根据每行的非零元素的数量将行放入不同的bins中
	- COMPRESS操作：忽略稀疏矩阵的所有零
- **Mapping 映射阶段**
	- BMTB(BMW,BMT)\_ROW(COL) \_BLOCK 操作：在行/列维度中拆分矩阵，每个矩阵都映射到一个线程块/warp/thread
	- BMT\_NNZ\_BLOCK 操作：将连续的非零元映射到线程
	- BMTB(BMW,BMT)\_PAD 操作：零填充到：块映射到线程块、块映射到warp、块映射到线程
	- SORT\_BMTB 操作：在块映射到线程块中，块中的每行按照该行非零元素的数量行进行降序排列
- **Implementing 实现阶段**
	- SET\_RESOURCES 操作：设置运行时配置
	- GMEM\_ATOM\_RED 操作：将中间结果原子地添加到全局内存
	- SHMEM\_OFFSET\_RED 操作：根据行偏移将多行的中间结果移动（还原）到共享内存
	- SHMEM\_TOTAL\_RED 操作：合并共享内存中同一行的中间结果
	- WARP\_TOTAL\_RED 操作：将每次wrap的所有中间结果合并到一行
	- WARP\_BITMAP\_RED 操作：通过位图合并每个wrap的所有中间结果
	- WARP\_SEG\_RED 操作：通过分段求和合并每个warp的所有中间结果
	- THREAD\_TOTAL\_RED 操作：将每个线程的所有中间结果合并到一行。
	- THREAD\_BITMAP\_RED 操作：通过位图合并每个线程的中间结果


给定一个稀疏矩阵，本文总结其SpMV程序通常分为三个步骤：
1. **定义矩阵的压缩内存布局**（即格式）==> <font color='red'><b>转换阶段</b></font>
2. **将其映射（分配）到不同并行级别的硬件单元**  ==> <font color='red'><b>映射阶段</b></font>
3. **设计核心实现**，主要是SpMV结果合并策略 ==> <font color='red'><b>实施阶段</b></font>

每个阶段包括多种设计或优化策略，称为**运算符**。定义运算符是非平凡且具有挑战性的，**需要大量准备工作从现有作品中抽象出优化策略，并验证它们在最终性能中的有效性**。为了原型目的，AlphaSparse目前仅考虑GPU上的运算符。在表II中列出了AlphaSparse中所有运算符。

在SpMV程序整体设计层面上，AlphaSparse通过Operator Graph 的三个阶段覆盖了整个设计过程。在设计策略层面（所谓的运算符），很难获得它们的定量和理论覆盖范围。目前，AlphaSparse已经涵盖了几乎所有高性能流行格式。

![image.png|center|1000](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20240606230913.png)
<center> <font face='华文宋体' size='4'> 图 5 ：格式生成示例 </font> </center>
上面是运算符图，下面是矩阵元数据集的子集。

#### 转换阶段

在转换阶段的运算符定义了稀疏矩阵压缩存储格式。
- ROW(COL)\_DIV 将整个矩阵分成横向或纵向条纹子矩阵，在操作图中分支。每个子矩阵可以在后续设计中单独处理（如图4右上角所示），有助于处理高度不规则的矩阵。
- SORT、SORT SUB 和 BIN 根据它们的长度重新排序矩阵行。
- COMPRESS 忽略稀疏矩阵的所有零以进行存储。

#### 映射阶段

映射阶段始终在COMPRESS运算符之后开始。
- 以`_BLOCK`为后缀的运算符将矩阵中相邻的非零元素切割成块，并将它们映射到不同级别的并行性。此阶段中的其他运算符进一步调整块内存布局。
- 以`_PAD`为后缀的运算符在矩阵特定位置添加零，以获得更规则化索引，提高性能。
- `SORT_BMTB`重新排序每个BMTB的行，可以减少排序范围并创造降低填充率的机会。


#### 实施阶段

在实施阶段的操作符与内核实现更相关。除了`SET\_RESOURCES`之外，所有操作符都以`RED`为后缀，这是BMTB、BMW或BMT的SpMV内核中间结果的不同合并策略。
- `GMEM\_ATOM\_RED` 直接且原子地将中间结果添加到全局内存中的向量y。
- 以`SHMEM_`为前缀的运算符是在共享内存中进行**线程块级**合并的策略。
	- SHMEM\_TOTAL\_RED适用于 BMBT 中所有中间结果来自同一行的情况。它将一个线程块的所有中间结果相加得到一个结果。
	- SHMEM\_OffSET\_RED 包括类似 CSR 的行偏移量 ，记录 BMBT 中每行的第一个中间结果的位置。它并行地合并每行的中间结果。
- 由`WARP_`前缀的三个运算符代表了合并**warp级别**的三种主流策略。 
	- `WARP_TOTAL_RED`是CSR-Stream中的经典策略。
	- 对于包含短行和长行的不规则矩阵，`WARP_BITMAP_RED`和`WARP_SEG_RED`使用位图和分段求和来按行合并BMW结果。
	- 为了从硬件的底层细节中获得更多优化机会，运算符利用GPU的一系列独特功能。<font color='red'><b>在warp级别操作符中，使用硬件级Warp Shuffle Functions 来实现高性能的归约</b></font>。
- 以`THREAD_`为前缀的操作符是**寄存器中线程级别**的归约。
	- THREAD\_TOTOAL\_RED 类似于其他后缀为TOTAL\_RED 的操作符。
	- THREAD\_BITMAP\_RED 串行地合并每行结果，使用位图来标记行边界。

操作符后面仍然有一个巨大的搜索空间，其中包含其详细参数（图1b中的参数空间），例如排序粒度、结果合并算法的并行性、阻塞大小等。一些从HYB、CSB 等格式派生出来的设计策略对于SpMV性能也至关重要，但尚未得到AlphaSparse的支持。AlphaSparse允许用户自行实现操作符。


### 4-2 操作图

<font color='red'><b>运算符图是通过按顺序连接操作符生成的</b></font>。 图5的上半部分显示了一个基本示例。 一个真正高性能的运算符图可能会更深，并且有时包括分支。 

 操作符之间存在依赖关系。 它们通常源于操作符的语义。 以图5中的运算符图为例，BMT\_ROW\_BLOCK 和 BMT\_PAD 不能跟在 BMTB\_ROW\_BLOCK 后面 。 因为当数据块已经映射到线程时，在CUDA中无法进一步拆分并映射到线程块作为更高级别并行性 。 用户也可以定义依赖关系以进行搜索修剪。


## 5-Format、Kernel Generator（格式、内核生成器）

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20240606232415.png)

给定一个操作图，可以移动到 SpMV 设计空间的特定位置。为了获得相应的格式和内核实现，**格式和内核生成器将此位置投影到格式、内核和参数空间**。与传统的源代码生成器不同，后者基于静态模板并且只关注内核实现，**格式和内核生成器需要通过两个组件来处理灵活的格式和内核组合**：<font color='red'><b>矩阵元数据集</b></font>和<font color='red'><b>内核构建器</b></font>。

### 5.1-矩阵元数据集

**矩阵元数据集包括对当前矩阵状态的多角度描述，记录了矩阵如何转换**。它是一个巨大的<font color='red'><b>键值内存数据库</b></font>，其内容用于生成格式和内核。

矩阵元数据集包含基本矩阵信息（矩阵大小、列数和行数、每列和每行的长度）、基本非零信息（父块索引、行索引、列索引）以及分布到不同并行级别的块信息（块大小、第一个非零索引、第一行索引、第一个子块索引）、约简信息（中间结果的行索引等）。

在操作符图中，**操作符通过按顺序修改矩阵元数据集来转换矩阵**。在迭代了操作符图之后，矩阵元数据集将累积包含所有操作符对原始矩阵的影响。

图5下部展示了一个简单的矩阵元数据示例。红色文本表示添加或修改元数据的位置。以行索引和列索引为例。它们由输入矩阵添加，记录非零值的行和列索引，并且操作符BMT\_PAD 进一步通过在特定位置（1, 1）添加零元素的索引来修改它们。

### 5.2-生成存储格式

**所有格式的数组都是通过选择内核所需的元数据从矩阵元数据集中提取出来的**。
![image.png|center|800](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20240606234255.png)

在图5中显示的最终格式中，bmtb nz偏移、bmt行偏移和bmtb bmt偏移记录了每个BMT或BMTB中第一个非零子块行的索引。它们由操作符BMT\_ROW \_BLOCK和BMTB\_ROW\_BLOCK生成，定义了矩阵如何分配给每个线程和线程块。bmtb的大小是每个BMTB中非零数目的数量，由 BMT\_PAD 生成。原始行（由 SORT 生成）和 bmt 行偏移记录了来自非零乘法结果的中间结果的原始行索引，这些对于 GMEM ATOM RED 的规约（在向量 y 中）是必要的。

### 5.3-构建计算内核

SpMV内核的构建过程包括两个部分：
- **分发**，主要由映射阶段确定。它获取不同并行级别中每个块的元数据，主要包括任务分配和合并策略的信息。
- **合并**，主要由实现阶段确定。它将矩阵的非零元素与向量元素相乘，并按行归纳合并它们的结果。

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20240606235020.png)
<center> <font face='华文宋体' size='4'> 图 6 ：通过剪接内核片段生成内核的示例 </font> </center>

根据SpMV程序的普遍性，Kernel Builder的模板包括两个关键组件：<font color='red'><b>内核骨架</b></font>和<font color='red'><b>内核片段</b></font>。
- **内核骨架：它是包含多个嵌套循环的根符号**。
	- 每个循环遍历分布在不同并行级别（线程块、warp、线程）上的块，其中包括一系列用于内核片段的插槽。
	- 标记为“获取BM\*(BMTB、BMT、BMW)元数据”的内核片段读取同一循环中其他内核片段所需的元数据数组，这构成了存储格式。通过分析数据依赖关系可以轻松自动生成。
	- 为了减少当前中间结果，以“reduction in”为前缀的内核片段由实现阶段中运算符确定。
	- 非正交因素可能出现在不同减少策略的组合中。为解决此问题，需要**预定义称为Adapter 的特殊内核片段**，其中仅包含几个赋值表达式。
		- 如图6右侧所示，在线程级别归约（THREAD\_TOTAL\_RED）产生的中间结果进一步在线程块级别归约（SHMEM\_OFFSET\_RED）中进行归约处理。前者将其输出放入寄存器组中；后者只接受共享存储器输入，并使得这两种减少策略不能直接连接起来。需要一个Adapter 将结果从寄存器复制到共享存储器以获得可接受布局形式。

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20240607000146.png)
<center> <font face='华文宋体' size='4'> 图 7 ：优化后生成的图5内核的示例 </font> </center>

图7显示了图5中显示的运算符图的示例内核。在这种情况下，整个矩阵在行方向上被划分为BMTBs和BMTs。每个线程将其内容减少到一个结果。来自线程的这些结果进一步在全局内存中减少。第3-6行和11-12行获取BMTB和BMT的格式（元数据）数组。第14-18行将每个BMT的非零乘以向量x的元素，并将它们缩小到由临时结果表示的一个寄存器中。第20-21行通过原子加法在全局内存中进一步减少每个线程的中间结果。

### 5.4-优化器

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20240607001426.png)

为了提高内核性能，Kernel Builder 支持一系列优化策略，如删除不必要的代码、组合多个短数据类型的数组等。由于内核优化以前已经得到了很好的研究，因此本文在调优系统中利用了一些最先进的技术。一个突出的优化是**模型驱动的格式压缩** ，它对内存访问优化特别有效。它通过将数组类型的数据(在内存中)转换为模型和用计算代替内存访问来减少内存访问的数量。

如图8所示，名为BMTB\_ROW\_DIV的操作符将矩阵每64行划分为行带，并将每个行带映射到一个线程块。它向格式中添加了一个名为reduce row offsets的数组，其中包括用于线程块级减少的BMTBs的第一行索引。可以直接从BMTB的索引计算出行偏移量（row offset=64\*bid），通过**将数组索引和值拟合到线性模型中来实现这一点**，<font color='green'><b>使得全局内存访问（row offset=reduce row offsets[bid]）变得不必要</b></font>。在手动编写代码时，程序员可以自然地发现数据结构的规律并直接编写优化实现。由于AlphaSparse是完全自动化的，需要明确执行此优化以达到与人工编写代码竞争性能相当。**除了线性函数外，还支持其他函数，例如阶跃函数和周期线性函数。用户还可以扩展假设函数**。与数据分析中常见回归问题不同，**在模型中存在任何错误都会导致SpMV实现不正确。为提高此优化成功率，可以容忍少量错误，并通过添加if语句来单独为模型无法适配的特定数组索引赋值。**

## 6-Search Engine（搜索引擎）

**搜索引擎通过枚举操作符图并选择最佳的一个来驱动 AlphaSparse**。

![image.png|center|400](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20240607001542.png)
为了处理由参数和操作符图结构组成的庞大搜索空间（作为第一部分详细介绍的挑战），<font color='red'><b>搜索引擎提供了从粗到细的多级搜索。它利用粗粒度搜索的经验，通过机器学习模型加速细粒度搜索</b></font>。

### 6.1-操作图搜索

搜索引擎的搜索策略包括三个步骤（级别）。
- 在第一步中，通过随机选择空操作符并将它们连接到现有操作符图的末尾来枚举图结构。
- 第二步在粗粒度网格中搜索操作符参数，并通过直接运行相应的SpMV程序获得操作符图的性能。
- 在第三步中，从第二步得到的测试结果进一步由ML模型插值到细粒度参数网格上。
本文不直接进行细粒度搜索，因为运行SpMV程序的开销非常高，甚至几乎占据了所有搜索开销。相比之下，ML模型的开销可以忽略不计。为了进一步合理地减少SpMV程序执行次数，前两个步骤可以通过模拟退火提前终止。此外，根据我们的经验，我们还将**搜索时间限制为不超过8小时**作为强制终止条件。

根据我们的实践，XGBoost 在插值方面表现非常出色，这也得到了TVM的验证。它实现了5% 的平均绝对偏差，甚至比GPU的性能波动还要小。由于架构的内存层次结构，推测内存受限程序的成本模型包括线性决策边界，这适合树状模型。第三步显著减少了参数搜索的开销。假设有一个具有 q 个参数的操作图。将搜索步长减半会使搜索空间增加 2q 倍，最终将搜索时间从几小时增加到几周。**XGBoost 可以通过产生相对可忽略的开销来实现相同效果**。

### 5.2-剪枝

尽管AlphaSparse提供了三级搜索以加速搜索过程，但由于AlphaSparse的巨大搜索空间，前两个步骤的开销仍然很昂贵。因此，除了粗粒度参数搜索和模拟退火外，还需要更多的修剪策略。

**修剪参数搜索**。 参数指示运算符的可量化细节。 最大的挑战是数组类型参数。 例如，ROW\_DIV包括一个数组类型参数，其中包含矩阵在行方向上分割的位置。 假设输入矩阵有105行，则仅此单个参数的搜索空间大小为105！，这是不可能掌握的。 每个运算符中都包含一种或多种参数离散化策略来处理数组类型参数。 参数离散化策略可以减少参数空间，特别是数组类型参数的空间。 在这种情况下，可以使用名为DIV\_IN\_ROW\_LEN\_MUTATION 的一种参数离散化策略来划分行长度变异的矩阵。 它将数组类型参数转换为描述此类突变程度的几个整数参数，这些整数可以轻松枚举出来。

**图结构的剪枝搜索**。当发现特定的矩阵稀疏模式不需要运算符时，增加了图结构的剪枝策略。例如，具有短行的矩阵不需要尝试运算符来减少长行。用户可以添加他们的修剪策略。AlphaS 解析根据已经存在的图的运算符和输入矩阵的稀疏模式，为剪枝运算符提供了一个禁止列表。

## 7- Evaluation

评估表明，AlphaSparse 在最先进的人工格式和传统自动调优的最新实现中提供了最高的整体性能。


### 7.1-实验设置

**平台**：实验在NVIDIA A100和RTX 2080上进行。前者基于安培架构，具有6912个CUDA核心，40GB HBM2内存（1.5TB/s），峰值性能为19.49 TFLOPS。后者基于图灵架构，具有2944个CUDA核心，8GB GDDR6内存（448GB/s），峰值性能为10.07 TFLOPS。我们在实验中使用单精度浮点数值。

**测试集**：实验包括来自SuiteSparse矩阵收藏的843个矩阵（其中大多数是不规则的），其特征满足以下三个条件：
- （1）行数大于9K
- （2）非零元素数量在50K和60M之间
- （3）没有空行。（因为：这篇文章中提到的机制没有包含处理空行的操作符。）
我们忽略了尺寸极大的矩阵，因为它们难以把握。小型矩阵也被忽略，因为它们不适合GPU。

### 7.2-对比样本

基线根据与SpMV的耦合程度分为三种：
- **人工格式**表示手动实现的特殊库。
- **格式选择器**代表传统的自动调优框架。
- **张量代数编译器**代表将SpMV视为许多对象之一的更通用编译器。

**人工格式**：
为了与人工格式进行比较，本文选择了几种性能高且具有不规则特定设计的流行先进格式，如下所示：
- 1）ACSR ，由我们实现，因为迄今为止我们还没有找到其高质量的实现
- 2）CSR-Adaptive，来自ViennaCL 1.7.1 
- 3）CSR5 
- 4）基于合并的CSR(Merge) 
- 5）HYB，来自cuSPARSE 9.2

**格式选择器**：
与基于格式选择的传统自动调优原理进行公平比较是不现实的。最先进的自动调优选择器，SMAT(ER)和clSpMV存在历史限制：
- 1）它们仅包含过时的格式，有时无法处理不规则性并且无法利用新GPU功能
- 2）长时间以来它们没有得到积极维护。
为了进行合理比较，本文实现了一个完美格式选择器（PFS），作为代表最新自动调谐器作为基准。

**张量代数编译器**：
编译器更注重代码级优化，而不是算法级设计。为了进行更充分的比较，本文将TACO 作为张量代数编译器的基准。

#### 7.2.1-与人工格式的比较

![image.png|center|800](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20240610232904.png)
<center> <font face='华文宋体' size='4'> 图 9 不同尺寸矩阵的 SpMV 整体性能 </font> </center>
图9a显示了AlphaSparse和843个矩阵中最先进格式的整体性能。x轴是矩阵大小，我们使用每秒浮点运算（GFLOPS）来表示性能作为y轴。AlphaSparse在所有人工格式中实现了最高性能。在A100上，AlphaSparse平均获得3.2倍加速，并且在所有人工格式中的最大加速达到22.2倍（在矩阵TSOPF RS b300 c2）。特别地，在ACS、CSR-Adaptive、CSR5、Merge和HYB方面，它分别比这些格式平均快2.3倍、5.7倍、2.0倍、2.0倍和3.9倍。AlphaSparse在全部843个矩阵中表现优于Merge、ACSR、CSR-Adaptive和CSR5，而对于841个矩阵也优于HYB（因为AlphaSparse没有包含HYB的矩阵分解策略）。在RTX 2080上，AlphaSparse平均获得2.0倍加速，并且在某些情况下最大可达8.3倍（例如，在矩阵TSOPF RS b2052 c1）。具体来说，相较于ACSR, CSR-Adaptive, CSR5, Merge 和 HYB ，它分别实现了平均快 2 倍, 23 倍 ,20 倍 ,17 倍 和24 倍 的提升。

Merge和CSR5在所有人工格式中提供了最高的整体性能，因为它们通过将平衡数量的非零元素或行分配给每个线程来受益于线程级负载平衡。CSR-Adaptive的整体性能最低。它在相对较小的矩阵中表现良好，实现更高的并行性。然而，由于放弃寄存器减少，导致其在剩余矩阵上表现最差。ACSR和HYB基于矩阵分解，提供了适度的性能。

在图9a 中，AlphaSparse 在每个矩阵大小中的最大性能组成了一个平尾形状的趋势，用红色虚线表示。作为一种内存受限程序，当矩阵大小不太大时，通过增加内存带宽的占用可以提高 SpMV 的性能。当内存带宽得到充分利用时，性能不会进一步提高。在我们的评估中，只有 AlphaSparse 接近这一趋势。

为了展示输入矩阵如何影响性能，本文取RTX 2080测试结果的样本，并将其分成两部分如图9b所示。选择这个结果范围是因为它显示出明显的上下边界，使得我们容易在中间进行划分。尽管这两部分案例对应相同的矩阵大小，但上半部分（红色）的性能比下半部分高达5.0×（平均1.4×）。根据进一步观察，我们怀疑**这种性能差距是由两个矩阵特征**引起的。
- 一个是**平均行长度**（$\frac{nnz}{n}$），在上半部分比下半部分高出1.9×。我们推测更高的平均行长度通过增加计算与内存访问之间的比率和减少SpMV程序中需要同步操作的缩减操作比例来提高性能。
- 另一个是**行方差**（规则程度，$\frac{\sum(row\_len-\frac{nnz}{n})^2}{n}$），在上半部分比下半部分低20×。较低规则度通常可以实现更高的缩减性能、更好地负载平衡和更少计算浪费。

#### 7.2.2-与格式选择器的性能比较
![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20240610233911.png)
<center> <font face='华文宋体' size='4'> 图10 A100上 AlphaSparse 加速比在 PFS 上的频率分布 </font> </center>
图10显示了AlphaSparse在A100上相对于PFS的加速比的频率分布。在99.3%的情况下，AlphaSparse的性能更高。在剩余的0.7%矩阵中，AlphaSparse表现较差，因为PFS中一些格式设计策略未包含在AlphaSparse中（详见第VII-H节）。大多数（40.8%）情况下实现了1.2×至1.4×之间的加速。

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20240610234104.png)
<center> <font face='华文宋体' size='4'> 图 11 PFS 上 AlphaSparse 的加速度对应于(a)矩阵大小和(b) A100上行长度的方差 </font> </center>
图11进一步展示了AlphaSparse相对于PFS的加速效果，同时提供了矩阵大小和行方差（以显示不规则稀疏性的影响）。图11a显示在矩阵适合A100的40 MB L2缓存时可以实现令人印象深刻的加速，在大型矩阵（≥107个非零元素）中提供较低的加速。在图11b中，红线显示了正则性和不规则性之间的界限（如前述102）。加速峰值为2.7×，出现在中等大小和不规则度量程内，这表明Operator Graph提供的细粒度权衡适用于适度稀疏模式。相反，大多数人工格式设计基于对特定极端稀疏模式（如Webbase、mip1、FullChip等）从矩阵及其论文中观察到。它们忽略了具有适度稀疏模式的矩阵。此外，我们发现不规则矩阵更受益于AlphaSparse：对于正常稀疏性，平均加速为1.4×；而对于不规则稀疏性，则平均加速增至1.6×。

#### 7.2.3-与 TACO 的性能比较
![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20240610234329.png)
<center> <font face='华文宋体' size='4'> 图 12 对应于(a)矩阵大小和(b) A100上行长的方差的 TACO 上的 AlphaSparse 的加速。 </font> </center>
AlphaSparse在性能上远远优于TACO。在A100上，AlphaSparse相对TACO实现了18.1倍的平均加速和最大950.8倍的加速。如图12a所示，与PFS不同，加速度对矩阵大小不敏感。图12b显示高度不规则矩阵中出现了加速峰值。有两个原因导致其相对较低的性能。**第一个原因是TACO并非专为SpMV而设计**。它的三个关键特性：索引压缩、循环优化和自动并行化，只针对一般稀疏问题。这些特性都无法处理由SpMV带来的问题，尤其是不规则性。**第二个原因是TACO缺乏利用GPU功能**，甚至与人工设计程序相比也欠竞争力。

### 7.3 搜索开销

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20240610234723.png)
<center> <font face='华文宋体' size='4'> 图 13 A100上的搜索迭代次数及行方差 </font> </center>

由于前两个搜索步骤几乎占据了所有的搜索开销（如第 VI 节所述），我们使用前两个步骤中的迭代次数来表示搜索策略的性能。图 13 显示了搜索迭代次数以及矩阵不规则度（即所谓的行方差）。测试结果的回归线说明了搜索开销与矩阵不规则度之间存在正相关关系：普通矩阵比高度不规则矩阵需要少 3.5 倍的迭代次数。这些证明了我们的修剪规则通过在输入矩阵为常规时忽略不规则操作符，显著降低了搜索开销。

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20240610235820.png)
表III显示了修剪策略如何影响AlphaSparse的搜索时间和性能。我们记录了来自已发表研究中评估的13个流行矩阵在修剪前后的测试结果。修剪策略平均减少了2.5倍的搜索时间。由于修剪策略包括高质量人类经验，它们消除了不必要的枚举，并使搜索引擎专注于设计空间中可能找到高性能格式的区域，在有限的搜索时间内进行查找。修剪策略还平均提高了1.2倍性能。与现有离线自动调谐器相比，例如PATUS（8小时）、SDSL（≥33小时）、Halide（2小时至2天）、PARTANS（2.5小时至32天），AlphaSparse 的搜索时间具有竞争力。

### 7.4-AlphaSparse 的创新能力

创建新的机器设计格式是性能改进的主要驱动力。从我们的统计数据来看，在73.1% 的测试用例中，AlphaSparse 通过创建源格式中没有涉及到的机器设计的格式(如表 II 中所引用的) ，表现优于所有相应的测试用例。在提供新格式的案例中，有16.5% 的分支出现在运算符图中，这意味着 AlphaSparse 为原始矩阵的不同部分设计不同的格式和相应的内核实现。

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20240611000217.png)
<center> <font face='华文宋体' size='4'> 在A100上矩阵scfxm1 − 2r的示例。 (a) 其操作图的快照，(b) 与人工格式的性能比较以及(c) AlphaSparse 的两个关键优化所实现的性能改进。 </font> </center>
图14a显示了由AlphaSparse生成的用于矩阵scfxm1-2r的新格式的操作符图示例。它主要包括来自SELL的线程块级阻塞策略，来自行分组CSR的线程级阻塞策略，以及来自CSR-Adaptive的减少策略。最终，如图14b所示，它比PFS和最先进的人工格式实现了2.7倍加速（这是最高值）。不同设计策略之间适当权衡可以实现高性能。与源格式相比，在这个矩阵中，机器设计的格式避免了SELL高填充率、行分组CSR低效全局内存减少、CSR-Adaptive忽视线程级减少，并受益于SELL规则行块索引、行分组CSR低填充率、CSR-Adaptive有效共享内存减少。就其最先进对应物而言，昂贵策略（例如ACSR划分和CSR5负载平衡阻塞）是不必要的，因为该矩阵并不太规则。此外，在这个矩阵中HYB包含一个庞大且低效COO部件，使其也比机器设计格式更差。图14c显示模型驱动格式压缩带来32%性能改善，并修剪策略带来额外78%性能改善。

### 7.5-局限性
在AlphaSparse中，**运算符的缺乏是导致特定矩阵性能略低的主要原因**。一个代表性案例是GL7d19矩阵。它最好的人工格式是HYB，其性能甚至比AlphaSparse自带的机器设计格式更好。在这个矩阵中，几乎所有行的长度都相对平衡，除了少数几行长数倍于其他行。HYB的矩阵分解策略非常适合这种稀疏模式，但当前版本的AlphaSparse尚未包含此策略。

除了类似HYB分解之外，还有两种流行类型的运算符没有被包括进来：用于本地密度、对角线模式 的运算符。它们将矩阵正则部分与其他部分进行隔离处理以实现高性能。然而，它们只覆盖了少量矩阵。我们原型实现并未考虑它们，但将会在未来考虑为更完整支持加入其中。

目前概念验证版AlphaSparse仅支持CUDA 。然而通过实现新定制操作符可以扩展到其他平台上去 。用户只需要定义操作符如何修改元数据，并偶尔需要定义内核片段即可 。

## 8-Related Work

自动调优器。自动调优器已被证明是一种成功的性能调优方法，代表作包括ATLAS、FFTW、SPIRAL和OSKI，适用于日益多样化和复杂的计算机架构设计。对于稀疏线性代数，SMAT、clSpMV、TileSpMV、Naser Sedaghati等人和CSX选择了最佳的人工格式和SpMV实现；而IA-SpGEMM为SpGEMM选择了最佳格式。TVM和Ansor是用于密集张量计算的自动调优器，通过自动生成代码结构并选择最佳参数。COGENT在GPU上提供了高性能的张量收缩。CASpMV在Sunway上包含了矩阵分区的自动调优器。一些通用的自动调优器，如ATF、OpenTuner、CLTune、Optuna、mNM、Muthu等人、Tiwari等人、Rigel和SMAC3，旨在简化自动调优器的设计工作，并在更广泛的范围内应用。AlphaSparse不仅限于在人工格式、内核实现、参数之间进行选择，它能够创建SpMV代码，突破人类设计的限制。

人工格式和内核设计。为了提高SpMV的性能，已经提出了几十种格式。最先进的格式是从几种基础格式派生而来的。ALIGNED_COO、SCOO、BRO-COO、BCOO派生自COO；ICSR、CSR-Adaptive、ACSR、CSR5、LightSpMV派生自CSR；ELL-R、AdELL、JAD派生自ELL；HYB、HDC和HEC是混合格式。这些人工格式是根据人类观察设计的，而AlphaSparse能够在无需人工干预的情况下自动创建格式。

代码生成。TVM是一个用于密集张量计算的基于模板的机器代码生成器。TACO可以通过压缩每个维度的索引来处理高阶稀疏张量计算。LL是一个用于定义矩阵格式及其SpMV内核的DSL（领域特定语言）。AlphaSparse提供了一种基于图的表达方式，用于生成格式和内核。


## 9-Conclusion and Future Work

本文介绍了 AlphaSparse，一个完全自动的 SpMV 代码设计器，它直接从输入稀疏矩阵生成高性能的格式和内核。它统一了格式建模和内核实现，在 NVIDIA GPU 上实现了高达22.2倍的人工设计格式加速。我们将研究现有研究的高级搜索策略，并在未来添加有效的格式转换例程。
