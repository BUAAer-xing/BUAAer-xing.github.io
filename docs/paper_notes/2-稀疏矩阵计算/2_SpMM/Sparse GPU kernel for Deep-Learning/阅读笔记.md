
[pdf](zotero://open-pdf/library/items/TMGX4DNV)

## 0-Abstract

科学工作负载传统上利用高水平的稀疏性来加速计算和减少内存需求。虽然深度神经网络可以变得稀疏，但在GPU上实现实际的加速是困难的，因为这些应用的稀疏性相对适中，不足以使现有的稀疏内核超越其密集对应物。

在本研究中，我们<font color='red'><b>研究来自深度学习应用的稀疏矩阵，并识别出可以利用的有利特性来加速计算</b></font>。基于这些见解，我们开发了针对两种在神经网络中广泛应用的稀疏矩阵操作的高性能GPU内核：SPMM和SDDMM。我们的内核在Nvidia V100 GPU上达到了27%的单精度峰值。使用我们的内核，我们展示了稀疏Transformer和MobileNet模型，实现了1.2至2.1倍的加速和高达12.8倍的内存节省，而不牺牲准确性。

![image.png|center|400](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250217212755.png)

<center> <font face='华文宋体' size='3'> 稀疏矩阵-矩阵乘法在权重稀疏长短期记忆网络问题上的运行时间。输入大小8192，隐藏大小2048，批量大小128，在Nvidia V100 GPU上使用单精度和CUDA 10.1。使用我们的方法，稀疏计算在仅71%的稀疏度下就超过了密集计算的性能。现有厂商库需要14倍更少的非零元素才能实现相同的性能。这项工作为突出区域内的所有问题提供了加速。 </font> </center>

## 1-Introduction

深度神经网络架构由用于矩阵乘法和卷积的大型密集矩阵组成。这些矩阵可以通过使其稀疏而几乎不损失模型质量，从而导致在实现给定准确性所需的浮点操作（FLOPs）和参数方面更加高效的模型。

**稀疏性在深度神经网络中最常见的应用是加速推理**。除了标准训练过程外，还应用稀疏化算法来生成一个高比例权重为零的神经网络。然后，权重矩阵可以以压缩格式存储，并且可以使用稀疏线性代数内核来加速计算。<font color='red'><b>在生成模型的背景下，稀疏性已被应用于降低Transformer架构中自注意力的计算要求</b></font>。除了这些应用，稀疏性还可以通过为固定的计算成本训练一个更大且稀疏的模型来实现更高的预测准确性。为了使训练大型稀疏模型成为可能，训练期间的所有计算需要直接在模型权重的压缩稀疏表示上操作。

稀疏性在深度学习中的潜在应用有很多。然而，由于缺乏高效的内核用于核心稀疏矩阵计算，例如稀疏矩阵-矩阵乘法（SpMM）和采样密集-密集矩阵乘法（SDDMM），因此在实际应用中实现稀疏性的好处是困难的。

在并行架构上，稀疏线性代数核的性能可能会因稀疏矩阵的特性而大幅变化，例如非零值的拓扑和稀疏程度。**现有的用于稀疏线性代数的GPU核主要针对科学应用进行了优化，在这些应用中，矩阵的稀疏度极高（99%以上）。** 由于深度神经网络中稀疏度相对适中，这些核无法超越其稠密版本。

为了解决这个问题，可以对非零元素的拓扑结构施加约束，使非零值被分组到块中。虽然这种方法能够恢复密集计算所取得的性能，但对非零元素位置的限制可能会显著降低相对于无结构稀疏性的模型质量。

在这项工作中，我们开发了<font color='red'><b>一种针对深度学习应用的在GPU上计算SpMM和SDDMM的方法</b></font>。我们的方法**直接在标准压缩稀疏行（CSR）格式上操作**，并且不对非零值的拓扑结构施加任何限制。我们做出了以下具体贡献：
- 我们**对深度学习中的稀疏矩阵进行了大规模研究**，识别出可利用的有利特性以加速稀疏计算。
- 我们引入了一种**一维tiling方案**，用于在处理单元之间分解计算，这有助于操作数的重用并且适合扩展实现。 
- 我们开发了两种技术，**sub-warp tiling** 和 **reverse-offset memory alignment**，使得在稀疏数据结构中可以在未对齐的内存地址上使用<font color='red'><b>向量内存指令</b></font>。 
- 我们引入了**row swizzle 负载平衡**，一种在处理单元之间进行负载平衡的计算方法，该方法与并行化方案解耦。

在来自最先进深度神经网络的大型稀疏矩阵数据集上，
- 我们在Nvidia V100 GPU上展示了SpMM和SDDMM相对于Nvidia cuSPARSE的几何平均加速比为3.58×和2.19×。
- 在表现最优的问题上，我们的内核达到了单精度峰值的27%。
- 在稀疏Transformer和MobileNet模型上，使用我们的内核，分别实现了1.22×到1.1×的端到端加速和12.8×的内存使用减少，同时保持与其稠密计算相同的精度。
 
 [开源地址](https://github.com/google-research/sputnik)

## 2-Sparse Matrices in Deep Learning

为了理解深度学习中稀疏矩阵的特性，我们基于大规模研究构建了一个稀疏深度神经网络权重矩阵的数据集。该数据集由在ImageNet上训练的ResNet-50模型和在WMT14英德翻译任务上训练的Transformer模型组成，并包括使用四种不同算法诱导神经网络稀疏性训练的模型。对于Transformer，我们将分析限制在WMT14英德测试集上达到20以上BLEU分数的模型。对于ResNet-50，我们包括在ImageNet验证集上达到70%以上top-1精度的模型。总共，该数据集包含来自49个不同模型的3,012个矩阵。

我们的分析集中在矩阵的三个特性上：行长变异系数 (CoV)、平均行长和稀疏度。。
- **矩阵行长度的CoV**是行长度的标准差除以其均值。高CoV表示稀疏矩阵的行之间存在负载不平衡。
- **平均行长度**捕获了在稀疏矩阵的每一行上将要完成的平均工作量。较长的行长度是理想的，因为启动开销和一次性成本可以在更多的有效工作中摊销。
- **稀疏性**衡量矩阵中零值的比例。根据具体实现，较低的稀疏性水平可以增加不同行中非零值落入相同列的可能性，从而为通过缓存重用操作数提供机会。

我们对比了深度学习工作负载与来自SuiteSparse矩阵集合的矩阵特性，该集合由2,833个稀疏矩阵组成，这些矩阵涵盖了广泛的科学工作负载，包括电路仿真、计算流体动力学、量子化学等。

![image.png|center|1000](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250217213043.png)

我们的深度学习矩阵和SuiteSparse矩阵集合的统计数据如图2所示。来自科学工作负载和深度学习的稀疏矩阵之间的差异相当显著：平均而言，深度学习矩阵的稀疏度低13.4倍，行长度长2.3倍，并且矩阵内行长度的变化量低25倍。我们认为，这些差异主要是由于保持高准确度的需求，这需要具有大量参数的深度神经网络。这反过来导致每行的非零元素数量增加，以及较低的变异系数，而变异系数与平均行长度成反比。**我们研究的每个指标中，深度学习矩阵展现出有利的特性，我们可以利用这些特性来加速稀疏矩阵计算**。

---

📒：有利的特征：
1. **较低的稀疏度（Less Sparsity）**
	- 深度学习中的稀疏矩阵通常**稀疏度较低**，平均比科学计算矩阵**稠密13.4倍**（即包含更多非零元素）。
	- 这意味着在深度学习中的稀疏矩阵仍然具有较高的计算密度，使得优化后的稀疏计算可以达到较高的性能，而传统科学计算的稀疏矩阵通常过于稀疏，难以利用GPU的计算能力。
2. **较长的平均行长度（Longer Average Row Length）**
	- 深度学习的稀疏矩阵中，**每行的非零元素数量平均是科学计算矩阵的2.3倍**。
	- 这意味着每个线程在执行稀疏矩阵运算时，每行包含的计算量较大，可以更好地**摊销（amortize）** 启动开销，提高计算效率。
3. **较低的行长度变异系数（Lower Row Length Variation, i.e., More Balanced Workload）**
	- 在深度学习的稀疏矩阵中，各行的长度变化较小，**行长度的变异系数（CoV, Coefficient of Variation）比科学计算矩阵低25倍**。
	- 这意味着计算任务在GPU上更加**负载均衡（Load Balancing）**，减少了线程之间的计算不均衡（warp divergence）问题，提高了并行效率。

深度学习的稀疏矩阵相比传统科学计算展现了**较低的稀疏度、更长的平均行长度以及更均匀的行长度分布**。这些特征使得本文提出的**优化稀疏计算内核**可以充分利用GPU的计算能力，提高SpMM和SDDMM运算的吞吐量，从而实现**高效的稀疏计算加速**。

---

## 3-GPU Background

本节提供了GPU架构和术语的基本描述。我们的实现使用CUDA编写，因此我们采用Nvidia使用的术语。

GPU由一组流处理器(SM)组成，GPU内核由一组线程组成，线程按32个一组聚集称为warp。warps再被聚集成称为线程块的更大线程集合。构成内核的线程块集合称为网格。当内核被启动到GPU进行执行时，每个线程块被调度到一个SM上。一组线程块称为一波线程块，该组线程块在GPU上同时运行。线程块内的所有线程可以通过快速的、程序员管理的、局部于SM的共享内存进行通信。所有线程还可以访问线程局部寄存器。并发执行在一个SM上的线程块数量被称为内核的占用率。较高的占用率通常是可取的，因为可以利用线程级并行性来隐藏内存和算术操作的延迟。GPU拥有一个较大但延迟高的全局内存，对所有SM都是可访问的，还有一个由所有SM共享的L2缓存，以及每个SM局部的L1缓存。当一个warp线程访问全局内存时，GPU会尝试将访问合并为尽可能少的事务。

## 4-Sparse Matrix Computation

本节解释由我们的 SpMM 和 SDDMM 内核实现的操作。

### 4.1-SPMM

我们的SpMM内核实现了计算 $AB \Rightarrow C$，其中 $A$ 是稀疏矩阵，并存储在标准的压缩稀疏行（CSR）格式中。在接下来的章节中，我们将矩阵 $A$、$B$ 和 $C$ 分别称为稀疏矩阵、稠密矩阵和输出矩阵。

### 4.2-SDDMM

SDDMM 操作被定义为 $AB \odot C \Rightarrow D$，其中 $C$ 和 $D$ 是稀疏矩阵，$\odot$ 表示两个矩阵的<font color='red'><b>逐元素乘法</b></font> 。由于采用了稀疏矩阵的逐元素缩放，可以跳过输出中零值位置的点积运算，从而加速计算。

在稀疏深度神经网络中，SDDMM 在多个关键计算中起着重要作用。例如，在权重稀疏的神经网络中，前向传播计算 $W X \Rightarrow Y$，其中 $W$ 是稀疏矩阵。在反向传播过程中，相对于稀疏权重的梯度计算为 $\delta Y X^T \odot \mathbb{I}[W] \Rightarrow \delta W$，其中 $\mathbb{I}[W]$ 是一个指示函数，在稀疏矩阵 $W$ 的非零值位置返回 $1$。在具有稀疏注意力的 Transformer 模型中，前向传播同样计算 $Q K^T \odot \mathbb{I}[Y] \Rightarrow Z$，其中 $Q$ 和 $K$ 分别是注意力机制的查询和键输入，$Y$ 是描述注意力机制连接性的稀疏矩阵。

这些计算在两个方面与严格定义的 SDDMM 不同。首先，它们不需要对稀疏矩阵值进行逐元素缩放。其次，作为 SDDMM 输入的矩阵 $B$ 通常是转置的。考虑到这些应用，我们的 SDDMM 实现计算 $A B^T \odot \mathbb{I}[C] \Rightarrow D$。尽管我们专注于深度学习中的计算，但我们的方法可以轻松扩展到一般的 SDDMM 计算。


### 4.3-数据组织形式

为了实现对所有输入和输出矩阵的合并内存访问，我们将稠密矩阵存储为行主（row-major）布局，并将稀疏矩阵存储为 CSR 格式。我们注意到，按照 $BA \Rightarrow C$ 计算 SpMM 也是同样高效的，其中 $A$ 是以压缩稀疏列（CSC）格式存储的稀疏矩阵，而 $B$ 和 $C$ 以列主（column-major）格式存储。
📒：这里估计是作者在写文章的时候写错了？？？？？？？？？？？

---
**行主布局（Row-Major Order）**：**按行优先存储**，即 **一行的数据是连续存储的**。
例如，一个 $3 \times 3$ 矩阵：
$$
A = \begin{bmatrix}
a_{11} & a_{12} & a_{13} \\
a_{21} & a_{22} & a_{23} \\
a_{31} & a_{32} & a_{33}
\end{bmatrix}
$$
在 **行主布局**（如 C 语言的 $float A[3][3]$）中的内存存储顺序为：
$\{ a_{11}, a_{12}, a_{13}, a_{21}, a_{22}, a_{23}, a_{31}, a_{32}, a_{33} \}$

**列主布局（Column-Major Order）**：**按列优先存储**，即 **一列的数据是连续存储的**。

 在 **列主布局**（如 Fortran、MATLAB 的默认存储方式）中的内存存储顺序为：
$\{ a_{11}, a_{21}, a_{31}, a_{12}, a_{22}, a_{32}, a_{13}, a_{23}, a_{33} \}$

---


## 5-SpMM Design

### 5.1- 分层 1-维 Tiling

![image.png|center|1000](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250217220403.png)

<center> <font face='华文宋体' size='3'> SpMM的分层分解使用一维 Tiling。为了简洁起见，采用4个warp在一个线程块中进行可视化。在每个分解级别中，矩阵A是以压缩稀疏行格式存储的稀疏矩阵，标记为绿色并显示在左侧。矩阵B是密集矩阵，标记为蓝色并显示在输出矩阵的顶部。输出矩阵C是密集的，标记为橙色并显示在每个级别的右下角。每个级别的深色区域表示下一个级别使用的数据。最左侧：每个线程块计算输出矩阵的一个一维 Tile。稀疏矩阵A的一行中的所有值都需要所有线程。我们使用线程块中的所有线程协作将A中的值和索引加载到共享内存，这样可以快速访问进行计算。对于从A加载的每个列索引，线程块将从矩阵B加载一个连续向量（标记为深蓝色横条）。中间左侧至最右侧：线程处理独立的输出，因此需要来自密集矩阵B的不同列子集。每个线程加载计算其输出所需的B中的值，并将其存储在线程局部寄存器中。 </font> </center>

我们在GPU上进行SpMM的方案如图3所示，并在图4中以CUDA伪代码的形式呈现。该分解遵循行分割方案，但有一个关键不同之处：<font color='red'><b>我们将输出划分为一维Tile，并将独立的线程块映射到每个Tile，而不是将线程块映射到输出矩阵的整个行</b></font>。

![image.png|center|400](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250217223435.png)

<center> <font face='华文宋体' size='3'> CUDA伪代码用于具有一维分块的稀疏乘稠密矩阵（SpMM）。输出矩阵在静态分区中被划分为一维分块。独立的线程块被启动来计算每个输出分块。在主循环的每次迭代中，我们加载稀疏矩阵的一维条带和稠密矩阵的二维分块，并累加向量矩阵乘积。在处理完该行中的所有非零值后，结果被写入输出矩阵。 </font> </center>

这种方法的动机源于这样一个事实：在深度学习应用中，稠密矩阵的列数可能会有很大变化。考虑具有稀疏权重矩阵和稠密激活的各种神经网络架构。
- 在训练RNN时，这个维度对应于批大小，通常在16到128个元素之间。
- 在Transformer架构中，这个维度是批大小和序列长度的乘积，可以从256变化到超过2048个元素。
- 在1×1卷积中，这个维度是图像高度和宽度与批大小的乘积。在EfficientNet架构中，空间维度的乘积范围从64到14,400。

1维-Tile 有三个主要优点。首先，我们可以很容易地为不同的Tile大小模板化我们的实现，并为问题空间的不同区域生成专门的内核变体。其次，对于M和K维度较小的问题，我们启动的线程块数量比通常可能的要多，从而实现更高的占用率和更高的峰值吞吐量的比例。最后，处理固定大小的块使我们能够积极展开循环，并在编译时计算偏移和常量。我们同样通过固定大小的步长迭代缩减维度，从而实现进一步的循环展开和静态评估。

### 5.2-向量化内存访问

向量内存指令是缓解带宽瓶颈和减少表达计算所需指令数量的重要工具。然而，在稀疏矩阵内核中使用这些操作并非易事。 

> [! warning] 💡
> 向量化内存访问，这个是不是可以添加到框架中？？？？

首先，**使用向量内存指令会增加线程块同时加载的值的数量**。例如，一个使用4宽向量加载的单个warp的线程块会在一次指令中请求128个浮点数。在我们的1D分块方案中，这意味着来自长度小于128的稀疏矩阵行的一些加载需要被条件化。同样，稠密矩阵中列数少于128的问题在内核执行的整个过程中，会有一些线程在每个线程块中被条件化关闭。这些约束限制了向量内存访问的实用性，特别是在未加处理的情况下，仅适用于非常大的问题。

其次，**向量内存访问要求目标值按照向量宽度对齐（2或4个32字节值）**。对于稠密矩阵或输出矩阵的访问，这要求列数能够被向量宽度整除，以确保每行值的起始位置正确对齐。更大的问题出在从稀疏矩阵加载数据。通过一维分块或行拆分方案，线程块内的访问从稀疏矩阵中一行值的起始位置开始。由于稀疏矩阵中的行可以具有任意长度，这些初始地址没有对齐保证，无论问题的维度如何。

#### 5.2.1 SubWarp Tiling

为了解决第一个问题，我们将我们的方案扩展为允许将一个warp的子集（即subwarp）映射到输出的独立一维tiles上。这通过使用的subwarp数量减少了访问宽度限制。这也使我们可以在输出矩阵的更多行中分散线程，以应对稠密矩阵和输出矩阵列数较少的问题。

通过subwarp平铺，我们的方案在warp级别上与标准的二维平铺方案有一些相似之处。重要的区别在于，处理输出矩阵不同行的subwarps无法重用从稠密矩阵加载的值。然而，根据稀疏程度，来自不同subwarp的访问很可能会表现出局部性，可以通过缓存来服务。

该方法的主要缺点是不同长度的行可能导致warp负载不均。我们在第五节C部分解决了warp中线程之间负载不平衡的问题。

#### 5.2.2 Reverse Offset 内存对齐

📒：**Reverse Offset Memory Alignment（ROMA）** 通过 **调整行起始地址** 使其对齐，从而 **启用GPU向量化内存访问**，并在**第一轮计算中掩盖错误数据**以确保正确性。

解决第二个问题的一个简单方法是用零对稀疏矩阵的行进行填充，使得所有行的长度都是四的倍数。然而，这限制了内核的普适性。为了在任意稀疏矩阵上启用向量内存指令的使用，我们在内核的设置部分引入了一个简单的技巧（即前言）：**在加载行偏移并计算行长度之后，每个线程块将其行偏移减少到最近的向量宽度对齐地址，并更新需要处理的非零元素数量**。为了保持正确性，线程在主循环第一次迭代中累加结果之前会屏蔽从上一行加载的任何值。

我们将这个技巧称为反向偏移内存对齐（ROMA）。相对于显式填充方案，ROMA并没有改变每个线程块所做的工作量。主要区别在于，ROMA不是显式填充矩阵数据结构，而是**有效地用前一行的值对稀疏矩阵的行进行填充**。

---

注意，稀疏矩阵的第一行保证是向量对齐的，因为<font color='red'><b>所有 CUDA 内存分配例程都以至少 256 字节的对齐方式分配内存</b></font>。

GPU的向量化内存访问要求数据起始地址必须按照向量宽度（如2个或4个32-bit数）对齐。但是，在**压缩稀疏行（CSR）格式**下，稀疏矩阵的每一行长度是**不固定的**，不同行的起始地址可能是**非对齐的（misaligned）**。

---

ROMA可以非常高效地实现。对齐过程在内核前奏中添加了6条<font color='red'><b>PTX指令</b></font>：2条位运算(`and`)、1条加法(`add`)、1条设置谓词(`setp`)和2条基于谓词选择指令(`selp`)。掩蔽过程在主循环的第一次迭代中添加了1条设置谓词(`setp`)和2条共享内存存储指令(`str.shared`)。

![image.png|center|400](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250218150158.png)
<center> <font face='华文宋体' size='3'> 用于在稀疏矩阵数据结构上启用向量内存操作的技术。上部分：子块铺助将一个warp的子集映射到输出的独立一维块。通过将<font color='red'><b>warp访问分散到多行</b></font>，我们减少了浪费的工作量。分配给warp/subwarp的行用蓝色标记。加载地址用箭头表示，条件加载用“X”表示。哈希区域表示通过warp/subwarp的一组加载加载的值。下部分：反向偏移内存对齐将<font color='red'><b>每行的地址备份到最近的对齐地址</b></font>。前一行的值在第一次循环迭代中被掩码以保持正确性。未对齐的地址用下划线标出。修改后的行起始地址用圆圈和行索引标记。 </font> </center>

这些使得向稀疏矩阵中使用向量内存指令的技术在图5中得以可视化。图8展示了我们SpMM内核的CUDA伪代码，其中包含了用于subwarp tiling和ROMA的必要修改。

### 5.3 Row Swizzle 负载均衡

已经提出了一些处理稀疏计算中负载不平衡的方法。然而，**现有的方法将负载均衡与并行化方案紧密耦合。虽然这些方案在负载不平衡显著时能够实现良好的性能，但它们通常会引入计算不规律性，这可能会对更规律的问题的性能造成损害**。然而，尽管在深度神经网络中发现稀疏矩阵的规律性，我们的内核仍然面临负载不平衡。

当将稀疏矩阵操作映射到GPU时，可能存在两个负载不平衡的来源。
- (a) **线程组或线程块之间的负载不平衡**：某些线程组/线程块可能分配的工作少于其他线程组/线程块。这可能导致一些流处理器闲置，而其他则在执行有用的工作。 
- (b) **线程组或线程块内的负载不平衡**：某些线程在一个线程组内的工作量可能少于其他线程。这可能导致线程组分歧，并在流处理器内造成数学单元和内存带宽的低效使用。

为了解决这些问题，我们有两个观察。
1. 首先，在内核执行过程中，许多不同大小的工作单元将被调度到每个SM上。
2. 其次，我们可以通过改变每个工作单元被分配给哪个线程来控制分配给哪个SM的工作。
基于这些观察，我们可以通过**重新映射工作调度的位置来确保工作负载在处理单元之间平衡**，从而<font color='red'><b>使每个处理单元（SM）分配到大致相等的工作量</b></font>。我们将这个**重新映射过程称为行混洗**。

为了应对这两种负载不平衡的来源，我们引入了两级工作重新排序：
- (a) **Row Binning**：在了解线程块如何映射到SM之后，调整 tile 映射，使每个SM接收大约相同的工作量。这有助于**解决warp/线程块之间的负载不平衡**。
- (b) **Row Bundling**：对于跨多个稀疏矩阵行的warp进行分割的内核，调整tile映射，使每个子warp接收大约相同的工作量。这有助于**解决warp内部的负载不平衡**。

#### 5.3.1- Volta线程块调度器

实现Row Binning方法，以使各个SM接收大致相同数量的工作是复杂的实现，因为这**取决于GPU的线程块调度算法**，这些算法并不公开。我们对Nvidia Volta线程块调度器进行了逆向工程，遵循了相同的一般方法。总体而言，Volta线程块调度器比Fermi线程块调度器简单得多。**第一波中的线程块根据其块索引分配给SM**。
$$sm\_idx=2(block\_idx\mathrm{~mod~}40)+\frac{block\_idx}{40}\mathrm{~mod~}2$$
其中$block\_idx$ 是计算出来的：
$$
block\_idx = blockIdx.x + blockIdx.y \times gridDim.x
$$
这个映射以轮询方式将线程块分配到SM上。在第一波之后，线程块按$block\_idx$的顺序调度，随着资源的可用。

#### 5.3.2-Row Binning & Row Bundling Heuristics

一种简单的Row Binning 启发式是选择第一波最重的N行捆绑，然后将接下来的N个最重的行捆绑与之前的捆绑按重量的反向顺序配对。为了按大小捆绑行，我们可以贪婪地从按大小排列的连续行中创建捆绑。

鉴于Nvidia GPU使用的在线线程块调度算法，这两种启发式方法可以通过<font color='red'><b>按行长度对行索引进行排序来实现</b></font>。给定一个按大小降序排列的行索引的排序数组，捆绑由连续行索引的块组成。第一波捆绑以轮询的方式在SM之间调度，剩余的捆绑按照优先级顺序调度，直到执行完成。我们注意到这种行分组的启发式方法类似于引导自调度。

该方法的一个优点是我们不需要知道目标捆绑大小便可以将相似大小的行分组。这意味着该启发式方法不需要了解底层使用的任何内核选择启发式。

![center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250218155603.png)

<center> <font face='华文宋体' size='3'> Row swizzle 方法用于稀疏矩阵计算的负载均衡。由同一warp处理的行被标记为相同的模式和颜色。我们引入了一层间接，以便在处理行时重新排序。【线程块内的负载均衡】为了平衡块内线程之间的工作，我们将相似长度的行分组成束。【线程块间的负载均衡】为了平衡SM之间的工作，我们按大小递减的顺序处理行束。 </font> </center>

由于DNN中稀疏矩阵的拓扑通常不常更新，因此按行长度对行索引进行argsort的成本可以在多个训练步骤中摊销。实现内核中的swizzle还需要在内核前奏中添加一个加载操作。**存储矩阵排序索引所需的内存微不足道**，因为对于我们目标应用，矩阵中的行数通常远小于矩阵中的非零元素数量。

![image.png|center|800](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250218155901.png)

图6显示了行swizzle负载均衡的高层方案。图7显示了在负载不平衡增加的情况下，行swizzle负载均衡在样本问题上的性能。图8显示了我们的SpMM内核的CUDA伪代码，包含进行行swizzle负载均衡所需的修改。

> [! warning] 💡后面的工作可以引入块内负载均衡


### 5.4 实现细节

本节详细介绍了我们为实现良好性能而应用的其他低级优化。
1) **Index Pre-Scaling**：在我们的内核主循环的每次迭代中，我们加载稀疏矩阵的值和索引，并将它们存储在共享内存中。每个索引将被所有线程用于从稠密矩阵中加载。为了避免每次加载索引时的重复工作，我们让每个线程在存储到共享内存之前缩放其部分索引。
2) **Residue Handling**：我们的<font color='red'><b>内核尽可能处理多个包含非零值的完整块，然后执行剩余处理程序来累积剩余的乘积</b></font>。**由于稀疏矩阵的行长度很少能被块大小整除，因此剩余处理代码的高效性至关重要**。为了最大化共享内存带宽并最小化bank冲突，我们尽可能使用128位共享内存加载指令。这对于主循环来说很简单，但对于剩余处理代码来说就困难了，因为剩余的非零元素数量不一定能被四整除。为了能够使用宽共享内存指令，我们在加载残余值和索引之前，将用于稀疏矩阵值和索引的共享内存缓冲区清零。然后我们将稠密矩阵加载和计算的循环分为两个，并将内部循环无界展开4倍。
3) **Mixed Precision**：除了标准的32位浮点内核外，我们还扩展了我们的SpMM实现，以支持混合精度计算，这在深度学习中很常见。我们的内核支持16位浮点输入/输出数据，并使用16位整数索引来处理稀疏矩阵的元数据。在我们的内核内部，我们将FP16数据转换为FP32，并发出FP32融合乘加指令，这是标准做法。在写入结果之前，我们将最终输出从FP32转换为FP16。由于16位整数的表示能力降低，我们不对混合精度内核执行索引预缩放优化。

```cpp
template <int kBlockItemsK>
__global__ void SpmmKernel(SparseMatrix a, Matrix b, Matrix c) {
    // 计算线程块对应的矩阵行索引
    int m_idx = blockIdx.y;
    
    // 读取CSR格式中该行的起始地址和非零元素个数
    int m_off = a.row_offsets[m_idx];
    int nnz = a.row_offsets[m_idx+1] - m_off;
    
    // **ROMA：对齐行偏移地址**
    MemoryAligner aligner(m_off, nnz);
    nnz = aligner.AlignedNonzeros();  // 计算对齐后仍需处理的非零元素数
    m_off = aligner.AlignedRowOffset();  // 更新起始地址，确保对齐

    // **第一轮迭代**
    Tile1D c_tile(/*init_to=*/0);
    if (nnz > 0) {
        Tile1D a_tile = LoadTile(a);
        aligner.MaskPrefix(a_tile);  // **掩盖因对齐回溯导致的错误数据**
        Tile2D b_tile = LoadTile(b);
        c_tile += a_tile * b_tile;
        nnz -= kBlockItemsK;
    }

    // **主计算循环**
    for(; nnz > 0; nnz -= kBlockItemsK) {
        Tile1D a_tile = LoadTile(a);
        Tile2D b_tile = LoadTile(b);
        c_tile += a_tile * b_tile;
    }

    // **存储计算结果**
    StoreTile(c_tile, c);
}
```

## 6-SDDMM

### 6.1-分层 1维 Tiling

我们对SDDMM使用与SpMM相同的一维Tiling方案，但有两个主要区别。
- 首先，我们**将线程块映射到连续非零值的一维条带，而不是输出的一维区域**。
	- 由于输出是稀疏的，这确保了线程块之间更好的工作分配，并且实现起来更简单。因为每行的非零值数量无法在不检查稀疏矩阵的情况下推断出来，所以我们启动了可能需要的最大线程块数量。在启动时，每个线程块计算是否有工作需要完成，如果不需要则提前返回。一种替代方法是使用动态并行。然而，我们在基准测试中没有观察到启动额外线程块的显著开销。对于目标为非常高稀疏度问题的SDDMM，动态并行可能会导致更好的性能。
- 我们工作分解的第二个区别是由于需要对右操作数进行转置计算。
	- 由于稠密矩阵以行主序布局存储，天真地在各个线程之间划分输出会导致对右矩阵的间隔且未合并的内存访问。为了避免这个问题，我们修改了方案，使得**映射到输出tiling的每个线程计算该tiling所有输出的部分结果。然后，我们使用warp shuffle指令在这些线程之间进行归约，以计算每个线程的最终结果**。
	- 这种方法的一个替代方案是在计算之前对从右矩阵加载的值在共享内存中进行转置。虽然这样每个线程使用的寄存器会更少，但这将使共享内存的使用量翻倍。在Nvidia Volta GPU上，共享内存和L1缓存使用相同的存储。因此，使用更多共享内存会减少L1缓存的大小。对于这些内核，我们发现L1缓存容量对性能很重要，因此决定不进行显式的共享内存转置。

📒：对于SPMM，将warp映射的依据是结果矩阵，因为结果矩阵是稠密的，并不需要提前预测非零元的位置。对于SDDMM，映射的依据是非零元，因为结果矩阵是稀疏的，提前预测非零元的位置，会引入额外的开销。

### 6.2-向量化内存操作

因为两个输入都是稠密的，因此在内维度可以被向量宽度整除的SDDMM问题中使用向量加载/存储是微不足道的。对于所有问题，我们在稀疏矩阵上使用标量加载/存储。这些操作仅在内核的开始和结束时发生，并不会显著影响性能。为了在更广泛的问题上启用向量加载/存储，我们使用subwarps处理输出tiles，如在SpMM的上下文中所解释的。

### 6.3-实现细节

虽然我们确实使用subwarp tiling来使向量内存指令能够应用于更广泛的问题，但由于所有要计算的点积长度相等，SDDMM中的负载平衡并不是特别关键。此外，深度神经网络中的问题通常具有可以被SIMT宽度整除的点积长度，这使得有效的余量处理在SDDMM中不如在SpMM中那么关键。对于SDDMM的余量计算，我们使用与主循环相同的循环结构，并且不对循环进行拆分优化，以启用广泛的共享内存加载。

## 7-Experiments

本节提供了我们SpMM和SDDMM内核的实证结果和分析。对于SpMM，我们使用了一种内核选择启发式方法，选择n维tile大小为N，向上取整为2的幂，最大为64。对于SDDMM，我们使用n维tile大小为32。对于这两个内核，我们使用了可能的最宽向量内存操作。所有基准测试均在CUDA 10.1下进行。

### 7.1-内核测试

#### 7.1.1-稀疏矩阵数据集

我们通过在深度神经网络中提取的稀疏矩阵数据集上进行基准测试，评估了我们提出的 **SpMM** 和 **SDDMM** 内核的性能。在数据集中，我们对 **3,012** 个稀疏矩阵分别使用 **训练（training）** 和 **推理（inference）** 的批量大小（batch size）进行测试。对于 **SDDMM**，我们测试了计算**稀疏权重矩阵梯度**相关的问题。对于 **ResNet-50** 中的卷积操作，我们采用 **im2col** 转换将输入数据转换为矩阵形式，并随后应用 **SpMM 或 SDDMM** 进行计算。在基准测试中，我们未将 **im2col 转换时间** 计入测试结果。此外，为了启用 **向量化内存指令（vector memory instructions）**，对于 **ResNet-50 推理批量大小（inference batch size）** 的测试，我们将批量维度填充至最接近的 **4 的倍数**。

![image.png|center|400](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250218165936.png)
  
所有基准测试均在 **Nvidia V100 GPU** 上进行。我们分别使用 **Nvidia cuSPARSE** 的 `cusparseSpMM` 和 `cusparseConstrainedGeMM` 作为 **SpMM 和 SDDMM** 测试的基线（baseline）。在 cuSPARSE 实现中，**稠密矩阵** 采用 **列主序（column-major）** 存储格式，而**稀疏矩阵** 采用 **CSR（Compressed Sparse Row）格式**。由于 `cusparseConstrainedGeMM` 不支持 **右侧操作数的转置**，我们使用 **cuBLAS** 进行显式转置，并将转置时间计入基准测试结果。所有测试均在 **单个 Nvidia V100 GPU** 上运行，测试结果在 **图 9** 中展示，测试统计数据在 **表 I** 中给出。

![image.png|center|1000](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250218164505.png)
<center> <font face='华文宋体' size='2'> 在我们的稀疏矩阵数据集上进行的基准测试，数据来自深度神经网络。运行时间（左侧y轴）和吞吐量（右侧y轴）随着每个内核和精度的问题规模增加而绘制。基准测试在Nvidia V100 GPU上进行。左上：单精度下的SpMM基准测试。在所有问题中，我们的方法实现了3.58倍的几何平均加速和14.2倍的峰值加速，超越Nvidia cuSPARSE。左下：单精度下的SDDMM基准测试。在所有问题中，我们的方法实现了2.19倍的几何平均加速和6.58倍的峰值加速，超越Nvidia cuSPARSE。右侧：混合精度下的SpMM基准测试，使用16位数据和32位计算。在所有问题中，我们的方法实现了5.97倍的几何平均加速和297.5倍的峰值加速，超越Nvidia cuSPARSE。 </font> </center>

在所有测试中，我们的 **SpMM** 和 **SDDMM** 内核相比 **Nvidia cuSPARSE** 展现出**显著的性能优势**：
- **单精度（single-precision）SpMM**：
	- **几何平均加速比（geometric mean speedup）** 达到 **3.58×**。
	- **峰值性能** 达到 **4.29 TFLOPs**，相当于 **单精度计算峰值性能的 27.3%**。
	- **在 99.75% 的测试问题上优于 cuSPARSE**。
- **单精度 SDDMM**：
	- **几何平均加速比** 达到 **2.19×**。
	- **峰值性能** 达到 **4.11 TFLOPs**，相当于 **单精度计算峰值性能的 26.2%**。
	- **在 93.34% 的测试问题上优于 cuSPARSE**。
- **混合精度（mixed-precision）SpMM**：
	- **几何平均加速比** 达到 **5.97×**，**峰值吞吐量** 达 **5.57 TFLOPs**。
	- 我们的 **SpMM 内核** 使用 **16-bit 整数（16-bit integers）** 作为稀疏矩阵的元数据，而 **cuSPARSE 仅支持 32-bit 索引**。我们推测这部分优化**进一步拉开了性能差距**。
	- **在 99.7% 的测试问题上优于 cuSPARSE**。
此外，我们发现 **cuSPARSE 的混合精度 SpMM** 在某些问题上表现不稳定，**相较于我们的内核，性能下降幅度可高达 297.5×**。


#### 7.1.2-稀疏RNN

本节评估了我们的内核相对于最近提出的技术的性能。由提供的SpMM内核仅支持批量大小为32的可被整除的问题。编写了SpMM和SDDMM内核，分别用于批量大小为32和128，并且还要求稀疏矩阵中的行数为256的倍数。考虑到这些限制，我们选择在来自**循环神经网络的问题数据集**上进行基准测试，其中由和提供的内核支持的问题配置对深度神经网络是现实的。我们在带有稀疏权重的RNN、门控循环单元（GRU）和长短期记忆网络（LSTM）问题上对每个内核进行基准测试。我们生成了随机均匀稀疏的稀疏矩阵。我们对状态大小为1k、2k、4k和8k，稀疏度为70%、80%和90%以及批量大小为32和128的问题进行了基准测试。所有基准测试均在单精度的Nvidia V100上执行。我们在基准测试中不包括由的自适应稀疏分块（ASpT）方法所需的预处理步骤的时间。我们对的行拆分内核进行基准测试，因为我们所有的基准测试都超过了作者选择行拆分和非零拆分内核所用的平均行长度阈值。基准测试结果见图10。

![image.png|center|1000](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250218165700.png)
<center> <font face='华文宋体' size='2'> 在稀疏递归神经网络问题上的基准测试。每个问题标记为 M/K/N/稀疏性。所有基准测试均在Nvidia V100 GPU上以单精度进行。顶部：SpMM基准测试。与ASpt相比，我们的内核实现了1.56倍的几何平均加速和2.4倍的峰值加速。与合并基础的方法相比，我们的内核实现了1.59倍的几何平均加速和2.15倍的峰值加速。与cuSPARSE相比，我们的内核实现了3.47倍的几何平均加速和4.45倍的峰值加速。底部：SDDMM基准测试。我们的内核在与适应性稀疏切片方法的比较中具有竞争力，平均达到92%的吞吐量，同时使用的内存减少了3倍，并且没有重新排序稀疏矩阵。与cuSPARSE相比，我们的内核实现了2.69倍的几何平均加速和3.51倍的峰值加速。 </font> </center>

对于SpMM，我们的方法显著优于其他方法。我们的方法在**MergeSpmm**、**ASpT**和**cuSPARSE**上分别实现了几何均值加速比1.56×、1.59×和3.47×。对于SDDMM，我们的方法明显优于cuSPARSE，并且在性能上与ASpT持平。我们的方法在cuSPARSE上实现了2.69×的几何均值加速，并在平均情况下达到了ASpT的92%吞吐量。

<font color='red'><b>虽然ASpT在SDDMM上取得了良好的性能，但它也有一些局限性</b></font>。
- 首先，包括原始CSR矩阵，ASpT需要3倍的内存来存储重新排序的矩阵以及进行块执行所需的元数据。
- 其次，作者的实现对SpMM和SDDMM问题使用了不同的稀疏矩阵重排序。
	- 对于深度学习应用，这意味着相对于稀疏矩阵计算的梯度将与在前向传递中使用的稀疏矩阵顺序不同。为了进行梯度更新或继续反向传播，应用必须在每次训练迭代中付出重新排序稀疏矩阵的成本。

### 7.2-消融实验

表 II 显示了我们对每个内核所提出的优化的消融研究结果。我们在包含训练和推理批量大小的 DNN 稀疏矩阵数据集上对这两个内核进行了基准测试。我们分别报告每个模型和批量大小的统计数据，以显示每种技术对不同问题空间部分的影响。

![image.png|center|400](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250218170144.png)

通过这些基准测试，我们发现像行调换负载均衡和残量展开这样的技术对不同的问题配置具有鲁棒性，而**向量内存指令在计算密集型问题中显示出较大的好处，而在小问题中则收益较小**。一个异常点是标量内存操作在 SDDMM 中的优越性能。在这些模型中发现的小权重矩阵使得这些问题主要受到占用率的限制，因此受益于我们的标量内核每个线程处理更少的输出。在第 10 节研究的 RNN 问题数据集中，我们观察到我们的向量内核相比于标量变体实现了 2.45 倍的几何平均加速。这些结果表明，更好的内核选择启发式方法可以大大改善性能。除了这些技术之外，我们的内核还得益于有利的数据布局和我们的 1D tiling 方案所实现的高效实现。

### 7.3-应用：稀疏Transformer

Transformer模型是一种流行的序列建模架构，已被用于在机器翻译、语言建模和图像生成等任务上取得最先进的结果。Transformer模型由堆叠的层组成，每层包含一个多头注意力机制，后跟一个小型全连接网络。Transformer中使用的注意力机制接受查询Q、键K和值V，并根据Q和K的相似性计算输入值的加权平均：
$$
Attention(Q, K, V) = Softmax\left(\frac{QK^T}{\sqrt{d_k}}\right)V
$$
其中 $d_k$ 是序列中每个元素的特征数。尽管这种架构有效，但 $QK^T$ 计算了序列中每个 token 与其他所有 token 之间的相似性，这要求计算和内存随着序列长度的增加而呈二次增长。**为了解决这个问题，最近的工作探索了在注意力机制中引入稀疏性。** 使用稀疏注意力时，我们计算 $QK^T$ 输出的一个子集，然后将其与 $V$ 相乘。<font color='red'><b>对于无结构稀疏性，这些操作相当于一个 SDDMM，后跟一个 SpMM</b></font>。

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250218171526.png)
<center> <font face='华文宋体' size='2'> Transformer注意力机制的连接性。上三角部分被屏蔽，以便令标记仅关注于其之前的标记。左侧：密集的全连接注意力。右侧：稀疏注意力，具有一个小的密集带和随机的离对角线的稀疏性，其概率与与对角线的距离成反比。 </font> </center>

- 实验设置：
	- 我们在 ImageNet-64x64 图像生成数据集上训练了带有稀疏注意力的 Transformer，该数据集的序列长度为 12,288。我们的模型由 3 层组成，每层有 8 个注意力头，每个头的隐藏维度为 1,024，且全连接网络中的滤波器大小为 4,096。我们使用批量大小为 8，在 140,000 个训练步骤中训练模型。**对于我们的稀疏模型，我们在训练过程中模拟稀疏性，并转换为稀疏表示用于基准测试**。尽管我们在进行图像生成任务的训练，但我们注意到这一架构可以应用于其他序列学习任务，如语言建模，而无需修改。
	- 对于我们的稀疏模型，我们生成了具有 256 大小密集带的注意力掩码，沿对角线排列，且非对角线部分随机稀疏，且稀疏性与距离对角线的距离成反比。我们将非对角线稀疏性设置为 95%。稀疏注意力掩码在整个训练过程中保持不变，并且被所有注意力头和层共享。我们模型使用的注意力掩码如图 11 所示。我们还额外编写了一个核函数，计算稀疏矩阵上的 softmax 函数。**对于每个模型，我们在单精度下基准测试前向传递**。
- 结果与分析：
	- 基准测试结果如表 III 所示。在 V100 GPU 上，我们的稀疏模型比标准 Transformer 快 2.09 倍，并且节省了 12.8 倍的内存，同时保持了相同的准确度。我们报告了每维度 以比特为单位的准确度。请注意，较低的每维度位数是理想的。除了在 V100 上的结果外，我们还利用我们的稀疏模型在 Nvidia 1080 上进行了内存节省的基准测试。在一个显著较弱的 GPU 上，我们的稀疏模型能够每秒处理 32,039 个 token，而标准 Transformer 则因内存不足而无法继续。稀疏 Transformer 的内存节省还可以用于训练更大规模的模型，从而提高准确性。

### 7.4-应用：稀疏MobileNet V1

MobileNetV1 是一种高效的卷积神经网络，用于计算机视觉任务。虽然最初设计用于资源受限的环境，但 MobileNetV1 在各个平台上都被发现具有很高的效率，并对计算机视觉模型的设计产生了重要影响。

MobileNetV1 由交替的深度卷积和 1×1 卷积组成。每个卷积后面都进行批量归一化和 ReLU 非线性处理。MobileNetV1 定义了一系列模型，其尺寸由宽度乘子控制。这些模型中的 1×1 卷积负责大多数的浮点运算，如果输入数据以 CHW 格式存储，则可以作为矩阵乘法进行计算。

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250218172439.png)

- 实验设置：
	- 我们**通过幅度剪枝将稀疏性引入 MobileNetV1 的 1×1 卷积中**。我们将所有模型剪枝到 90% 的稀疏度。我们保留第一层为密集层，因为我们发现该层受限于激活矩阵的带宽，因此从权重稀疏中获得的好处较少。我们在 ImageNet 数据集上使用 32 个加速器训练我们的基线模型，共计 100 个周期。由于我们的目标是在推理成本超过训练成本的情况下实现高效推理，我们将稀疏模型的训练时间增加 10 倍，这有助于稀疏模型在剪枝过程中收敛。
	- 在推理时，批量归一化可以与前面的线性操作融合。我们对所有深度卷积和 1×1 卷积都执行此操作。对于深度卷积，我们编写了支持融合偏置和 ReLU 操作的内核。我们同样将偏置和 ReLU 融合到稀疏的 1×1 卷积中。对于我们的密集基线中的 1×1 卷积，我们使用 Nvidia cuBLAS，该库由高度优化的汇编内核支持。我们还编写了一个融合偏置 + ReLU 的内核，在这些线性操作之后使用。对于我们的稀疏模型，我们使用一个针对四个 1×1 卷积的最佳内核选择器，其中我们的启发式方法并不最佳。对于每个模型，我们在 Nvidia V100 GPU 上以单精度进行推理基准测试，批量大小为 1 张图像，这在自动驾驶等在线推理应用中是常见的。
- 结果与分析：
	- 我们的基准测试结果如图 12 和表 IV 所示。总体来看，我们的稀疏模型在给定准确率的情况下提供了 21-24% 的加速，或者在相同吞吐量下，准确率提高了 1.1%。
	- 由于剪枝导致的准确率损失，我们的稀疏模型比其匹配准确率的密集模型更宽。增加的宽度也增加了非稀疏操作相对于密集基线的成本。**更好的剪枝算法将有助于缓解这个问题，并实现进一步的加速**。此外，在 1×1 卷积剪枝后，深度卷积成为一个显著瓶颈。调整这些内核将为我们的稀疏模型相对于其密集 counterparts 带来进一步的收益。


## 8-Related Work

## Discussion and Conclusion

除了我们讨论的核函数外，训练深度神经网络（DNNs）需要计算 $A^T B \Rightarrow C$，其中 $A^T$ 是稀疏矩阵的转置。对于 CSR 矩阵而言，将转置操作直接融合到 SpMM 中是困难的。然而，在 DNN 训练过程中，可以在稀疏矩阵拓扑更新时缓存 $A^T$ 的行偏移量和列索引，并通过矩阵值的 argsort 操作执行转置。

另一种稀疏矩阵格式是一个有趣的方向，可以支持转置和非转置计算 。

在大规模问题中，我们的核函数的性能受限于共享内存带宽。缓解这一瓶颈的一个方向是重用从右输入矩阵加载的值，使其可被左输入矩阵的多行共享。

尽管我们的核函数非常高效，但它们无法利用专用的矩阵乘法硬件。对于非结构化稀疏性，通过在共享内存中解压缩稀疏块可能使得这些运算可用。硬件的新进展可能会进一步支持这一点 。尽管会导致模型质量下降，但仍然可以利用该硬件来支持向量和块稀疏性。

在本研究中，我们展示了深度神经网络中的稀疏矩阵具有有利的特性，可用于加速计算。基于这一见解，我们设计了专门针对深度学习应用的高性能 SpMM 和 SDDMM 核函数。利用我们的核函数，我们展示了稀疏 Transformer 和 MobileNet 模型，分别实现了 $1.2$–$2.1\times$ 的加速，并在不牺牲精度的情况下，实现了高达 $12.8\times$ 的内存节省。我们希望这些发现能促进深度学习框架对稀疏性的更好支持，并更广泛地推动稀疏性在深度学习中的应用。








