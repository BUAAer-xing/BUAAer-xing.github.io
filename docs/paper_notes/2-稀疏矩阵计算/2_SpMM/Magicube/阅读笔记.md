
[pdf](zotero://open-pdf/library/items/FN57TEAG)

## 0-Abstract

模型规模的指数增长推动了深度学习的持续成功，但也带来了难以承受的计算和内存成本。**从算法的角度来看，模型稀疏化和量化已被研究以缓解这一问题**。从架构的角度来看，硬件供应商提供Tensor核心以加速计算。然而，**由于对数据布局的严格要求以及缺乏有效操作低精度整数的支持，从稀疏的低精度矩阵运算中获得实际加速是非常具有挑战性的**。

我们提出了Magicube，一个针对Tensor核心的<font color='red'><b>低精度整数</b></font>的高性能稀疏矩阵库。Magicube支持SpMM和SDDMM，这两个在混合精度下的深度学习中的主要稀疏操作。在NVIDIA A100 GPU上的实验结果表明，Magicube在稀疏内核上平均实现了1.44倍（最高可达2.37倍）速度提升，相比于供应商优化库，而在端到端的稀疏Transformer推理中，Magicube则实现了1.43倍的速度提升，且具有可比的准确性。


## 1-Introduction

在最先进的深度学习中，近期的进展是由计算、数据和模型规模的不断增加推动的，这一扩展趋势预计将持续下去。这些大规模深度学习模型在训练时需要大量的能源和碳排放，并且在有限的计算和内存资源下评估推理是具有挑战性的。**减少内存占用和推理延迟的主要技术是矩阵运算的<font color='red'><b>稀疏化和量化</b></font>**。

虽然这些压缩方法在理论上减少了操作数量，加速了每个操作，并提高了内存带宽，但在加速器上获得实际加速并不容易。在深度学习中，**为了保持模型的预测准确性，能够实现的矩阵稀疏度相对较小**（例如，50-90%）。因此，利用如cuSPARSE提供的以高稀疏度为目标的稀疏内核（例如，> 99%），很难超越其稠密对应物（例如，cuBLAS）的性能。为了在加速器上获得实际加速，<font color='red'><b>cuSPARSELt</b></font>利用Tensor Cores稀疏性，并在几种低精度数据类型（例如，fp16、int8、int4）中实现了与稠密对应物的双峰性能。然而，**该库对数据布局施加了严格的限制（即，2:4结构稀疏性），稀疏度限制为50%**。Gale等人提出了<font color='red'><b>Sputnik</b></font>，这是一个用于稀疏矩阵-矩阵乘法（SpMM）和采样稠密-稠密矩阵乘法（SDDMM）的库，支持fp32和fp16数据类型，**利用深度学习中矩阵的特性（例如，每行的非零元素较多），并采用细粒度稀疏数据布局**。在中等稀疏度（例如，70%）下，Sputnik在NVIDIA V100 GPU上的fp32深度学习工作负载中优于cuSPARSE。Chen等人指出，在使用低精度时，现有的稀疏内核无法在稠密对应物上实现加速，**因为缺乏数据重用**。此外，他们还表明，cuSPARSE中的块稀疏矩阵乘法的SpMM内核需要块大小大于8才能实现加速。这使得保持模型准确性变得更加困难。为了解决这些问题，他们提出了<font color='red'><b>vectorSparse</b></font>，这是一个使用稀疏编码的库，采用形状为例如8 × 1、4 × 1的稠密一维块，能够在保持数据布局灵活性的同时提高fp16中的数据重用。

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250221235745.png)

这些结果是一个更大问题的一部分：哪些低精度数据类型和稀疏性组合应该在硬件中得到支持，哪些则可以在软件中得到支持。结合<font color='red'><b>稀疏性和量化在深度学习中已被证明是极其有效的</b></font>。然而，两者有不同的权衡，硬件供应商必须在这个昂贵的设计空间中为每个产品选择一种配置。此外，由于缺乏对低精度整数（例如，int4）的高效操作支持，在Tensor核心上实现高性能的稀疏和量化矩阵操作面临挑战。在我们的工作中，我们为NVIDIA A100 Tensor核心定义了两个额外的软件设计点，使用我们的Magicube1库：
- （1）具有低精度整数类型的小型一维块稀疏操作，
- （2）具有混合精度的小型一维块稀疏操作。
需要注意的是，在这项工作中，我们将混合精度定义为矩阵乘法的两个输入矩阵具有不同的精度。在深度学习中，为不同类型的量（例如，权重、激活）分配不同精度的数据类型，考虑到对量化的不同敏感性，已被证明**在减少精度下降和提高硬件效率方面都是有效的**。表I总结了各种数据类型在GPU上的最先进的稀疏矩阵库。

我们在这些类型组合上，通过高效地将输入传递到张量核心并代数地模拟低精度和混合精度整数操作，始终比现有所有库的性能提高了超过40%。我们还展示了**这些优化转化为Transformer网络端到端性能提升超过40%**，这是当今及未来大规模深度学习系统中最有前景的候选者。我们的主要贡献是：
- 我们设计了一种针对低精度整数在Tensor核心上友好的**稀疏矩阵格式SR-BCRS**。
- 我们引入了高度优化的SpMM和SDDMM内核。具体而言，我们提出了**一种新颖的在线转置策略**，以高效处理细粒度数据并满足数据布局要求。
- Magicube**支持混合精度**，使用高效的代数类型模拟，通过操作堆叠提高了Tensor核心的利用率。
- Magicube在最新的稠密和稀疏库上实现了显著的加速，**适用于微基准测试和实际深度学习应用**，同时模型的准确性也得到了验证。

我们评估了在1536个不同大小和稀疏度的稀疏矩阵上稀疏内核的性能。在NVIDIA A100 GPU上的结果表明，Magicube在SpMM上相对于**cuSPARSE**平均实现了1.44倍的加速。对于端到端稀疏Transformer推理，Magicube相对于**vectorSparse**（在Tensor核心上使用fp16的最先进稀疏库）实现了1.43倍的加速，相对于使用cuDNN的**PyTorch**（fp16稠密库）实现了1.50倍的加速，并且具有可比的准确性。

## 2-Background and Related Work

### 2.1-深度学习中的压缩

<font color='red'><b>稀疏化</b></font>和<font color='red'><b>量化</b></font>是压缩深度神经网络的常见方法，以降低训练和推理的能耗和性能成本。
- **稀疏化**通过忽略对学习和预测贡献较小的操作数中的冗余元素，减少工作负载中的操作数量（例如，矩阵乘法、卷积）。
- **量化**通过使用低位表示操作数，例如fp16、8位和4位整数，加快每个操作的速度并提高内存带宽。
两者都通过压缩神经网络权重、输入和中间表示（激活和反向传播误差）来减少存储要求。

近年来，基于注意力机制的Transformer模型在各种领域应用中逐渐成为主流，例如自然语言处理和计算机视觉。由于使用大型Transformer模型（例如BERT，GPT-3）进行预训练和微调范例的有效性已被证明，减少训练和推理过程中的碳排放、能源消耗以及计算和内存成本的重要性日益增加。为了减少内存占用和推理延迟，<font color='red'><b>针对巨型Transformer模型的权重剪枝和量化已被研究</b></font>。还研究了注意力图稀疏化，以降低自注意力的计算和内存复杂性，这些复杂度与序列长度的平方成正比。

### 2.2-稀疏和量化操作的优化

压缩导致稀疏和量化操作，但需要适当的硬件和/或一系列性能优化来实现实际的加速。**科学计算中稀疏矩阵操作的性能优化已被研究。然而，这些领域中假设的矩阵稀疏度通常超过99%，而在深度学习中，为了保持神经网络的预测精度，稀疏度通常在50-90%之间**。因此，在深度学习工作负载上实现相对于密集操作的加速更具挑战性。

AI加速器，如Tensor核心，带来了前所未有的深度学习工作负载低精度（浮点和定点）的性能。但这主要针对密集矩阵乘法。**结构稀疏性在Tensor核心上也原生支持，但对非零元素的分布有严格的要求**，例如50%的稀疏率，以及稀疏模式，例如1:2或2:4，这可能限制其通用性和可用性。Gale等人提出了<font color='red'><b>Sputnik</b></font>，优化了CUDA核心上深度学习工作负载的性能，支持更一般的细粒度稀疏性，并且相对较低的稀疏性优于cuSPARSE。Chen等人提出了<font color='red'><b>vectorSparse</b></font>，以提升Tensor核心上**结构稀疏性的性能**（约束更少）。但Sputnik和vectorSparse都针对半精度下的稀疏工作负载。与之前的工作不同，我们专注于低精度整数的量化稀疏矩阵运算（SpMM和SDDMM），并呈现出卓越的性能。

### 2.3-NVIDIA 图形处理器的张量核与低精度整数的数据布局

NVIDIA GPU由一系列流处理多处理器(SM)组成，每个SM包含小的处理组件(如CUDA核心和Tensor核心)。CUDA( NVIDIA GPU编程模型)内核通过多线程执行。GPU内核中的线程通过线程块的网格组织，每个线程块由warp组成(每个warp有32个线程)。warp是CUDA中的基本调度单位。

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250222112411.png)

自Volta架构以来，NVIDIA GPUs增加了张量核心单元（TCU），该单元专门为深度学习设计，提供比CUDA核心上的浮点运算单元（FPU）高出8倍的峰值FLOPs（pf16）。在新架构如Ampere和Hopper上，张量核心支持低精度整数（8位、4位甚至1位）的矩阵乘法，这提供了比fp16更高的双倍、四倍或更高的峰值性能。如表II所示，张量核心几乎提供了NVIDIA GPUs上低精度整数的所有计算能力。因此，我们针对张量核心优化深度学习的量化稀疏内核。在后续内容中，我们使用intx表示x位的整数。

为了在张量核心上编程，CUDA提供了具有矩阵乘法-累加（MMA）语义的warp级API，其中32个线程的warp协同执行一个或多个密集矩阵乘法并累加输出。从编程的角度来看，CUDA提供了两个具有MMA语义的API，包括（高级）C++中的`WMMA`和（低级）NVPTX（准汇编语言）中的`mma`。在Magicube中，我们使用mma API。关于深度学习的极低精度（int2或甚至int1）密集操作已在相关文献中进行研究。在本研究中，我们关注适度精度（例如int4、int8）与稀疏性。

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250222112714.png)

<font color='red'><b>在Tensor核心上，对于每种精度，支持几种形状的mma。</b></font>int4和int8的支持形状如表III所示。在Magicube中，我们选择使用最小的形状（如表III中突出显示）以**在小稀疏粒度下发挥性能**，因为在相同稀疏比的情况下，较小的粒度通常能够获得更好的准确性结果。对于int8和int4的mma，我们分别使用m8n8k16和m8n8k32的形状。形状为m8n8k16的int8 mma的数据布局如图1所示。

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250222113939.png)

输出矩阵C的形状（每个元素为int32）为m\*n（即8\*8），而还原维度为k=16。左侧矩阵A的形状为8\*16，右侧矩阵B的形状为16\*8，A和B的每个元素都是int8。如图1所示，<font color='red'><b>A、B和C的元素均匀分布在一个warp（32个线程）的寄存器中</b></font>。请注意，A必须是行主序，B必须是列主序。每个线程向A和B提供4个int8元素。<font color='red'><b>程序员必须将整个工作负载分解为小的MMA（例如，m8n8k16），并匹配对A、B和C的数据布局的限制要求</b></font>。形状为m8n8k32的int4 mma的数据布局与形状为m8n8k16的int8相似，只是A和B的每个元素为int4，还原维度k增加到32，而每个线程向A和B提供8个int4元素。

## 4-Implementation and Optimization for SpMM in Deep Learning

### 4.1-稀疏格式

稀疏矩阵在科学计算和深度学习领域是重要的工作载体。压缩行存储（CRS）格式是压缩稀疏矩阵的最流行方法，因为它简单。块压缩行存储（BCRS）格式进一步提出，以改善对L1缓存或寄存器的数据重用。在**vectorSparse中使用的列向量稀疏编码是BCRS的一种特殊情况**，其中每个密集块是一个一维块。BCRS与一维块的示例如图2所示。

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250222125326.png)

由于具有1-D稠密块的BCRS足以在稀疏深度学习工作负载中利用数据重用，且小的稀疏粒度对模型精度有利，因此我们也<font color='red'><b>将重点放在结构稀疏性和1-D稠密块上，而不是2-D稠密块</b></font>。不同于之前的工作，为了利用在Tensor核心上的低精度整数稀疏工作负载的性能，我们提出了一种**跨步行主序BCRS（SR-BCRS）格式**。现在我们通过与BCRS格式的比较来介绍SR-BCRS的细节。

BCRS由行指针、稠密（非零）向量的列索引以及存储在连续数组中的稠密向量组成。相比之下，SR-BCRS中的稠密向量采用跨步行主序方式存储，如图2底部所示。如果向量行中的稠密向量数量不是跨步长度的整数倍，则最后一个向量行会填充零值。对应地，列索引也填充无效值（\*）。这里跨步大小等于我们使用的mma操作的缩减（即k）维度。例如，int8的mma操作的跨步为16。通过这种方式，**warp中的线程可以连续加载LHS矩阵的数据到寄存器中**，数据布局要求（如图1所示）得以直接满足。这里SR-BCRS支持的1-D稠密块长度（V）小于等于8（即mma的m维度）。如果V=8，mma操作将得到充分利用；如果V=4，mma的利用率为50%。为了支持这种跨步格式，我们需要2M（M为稀疏矩阵的行数）行指针。对于每一行，我们需要一个指针指示第一个稠密向量的地址，另一个指针指示当前向量行中的最后一个稠密向量。

### 4.2-Magicube下的SpMM

稀疏矩阵-矩阵乘法（SpMM）是深度学习中的一个主要稀疏工作负载。例如，在一个经过剪枝的模型的前向传播中，稀疏权重矩阵将与稠密激活矩阵相乘。在稀疏Transformer中，自注意力通过将稀疏注意力权重矩阵与稠密值矩阵相乘来计算。这些都导致了一个SpMM操作。图3(a)显示了一个具有结构稀疏性的SpMM示例（即1-D块），其中矩阵A可以被视为一个带有结构稀疏性的剪枝权重矩阵或稀疏注意力掩码。注意，<font color='red'><b>稠密向量的列索引用于加载稠密矩阵B的相应行</b></font>。

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250222130410.png)

#### 4.2.1-SpMM中的线程块

图 3(b) 显示了在 Magicube 中 SpMM 在线程块级别的实现。由于我们关注量化稀疏矩阵运算，这里假设矩阵 $A$ 和 $B$ 的元素均为 int8 类型。假设每个线程块包含 2 个 warp，每个线程块负责计算一个大小为 $BS_m \times BS_n$ 的输出块。其中，$BS_m = V$（即向量长度）。$BS_m$ 可以设为 $V$ 的倍数，但这并不能有效提高数据复用率，因为每行向量可能具有不同的列索引。在每个计算步骤中，每个线程块通过归约维度 $BS_k$ 计算部分结果。这里，$BS_k$ 等于 SR-BCRS 格式中的步幅大小，同时也等于 mma（矩阵乘加）运算的归约维度。总体而言，每个线程块需要 $nnz / BS_k$ 步（累积部分结果）以获得最终结果。得益于 SR-BCRS 格式，mma 计算中左手边（LHS : Left-Hand-Side）矩阵的数据布局需求可以通过连续地以步幅方式加载数据直接满足。<font color='red'><b>LHS 矩阵从全局内存到共享内存的加载是 合并（coalesced） 方式进行的，并且数据在 warp 之间共享。</b></font>

> [! warning] 💡:通过统计访问B矩阵中稠密行对应的次数，选出前$x\%$的稠密行，提前加载到L2 Cache中，来提升访问的效率？


#### 4.2.2-具有int8的密集矩阵B的有效在线转置

> [! error] 对共享内存中的bank冲突理解还不是很明白！

接下来，我们讨论如何将 $B$ 的数据块馈送到 $mma$ 的右侧矩阵（RHS）。在这里，我们使用行主序存储稠密矩阵 $B$。然而，**回想一下，$mma$ 的右侧矩阵必须是列主序的，这就导致了布局的不匹配。预先将 $B$ 转置为列主序并没有帮助，因为稠密向量的列索引并不连续**。因此，我们提出了一种高效的<font color='red'><b>在线转置策略</b></font>，适用于行主序的 $B$ 块，该策略包含三个主要步骤：
- 首先，线程块中的线程协作加载 $B$ 的行数据，从全局内存加载到共享内存的填充缓冲区。例如，图 4 显示了一个 $BS_n = 64$ 的示例。每行 64 个 int8 值被合并为一个单独的 64B 内存事务，从而提升了全局内存访问效率。请注意，我们可以设置 $BS_n = 128$，以将其合并为一个 128B 的内存事务，从而在大规模 $N$ 下提高效率。
	- ![image.png|left|400](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250225193434.png)
- 第二，每个线程将从共享内存加载 4 个 int32 项到局部寄存器中。线程通过对局部寄存器进行转置，按 int8 粒度进行操作，如图 5 所示。转置后，寄存器块中的每一行包含来自矩阵 $B$ 列的 4 个连续的 int8 值，满足 $mma$ 的数据布局需求。请注意，每个线程在转置后的寄存器块中有 4 行数据，这些数据分别送入 4 个 $mma$ 运算的右侧矩阵。因此，对于两个 warp 线程块，每个步骤需要执行 8 次 $mma$ 运算，如图 6 所示。
	- ![image.png|left|400](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250225193543.png)
	- ![image.png|left|400](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250225193801.png)


在 NVIDIA GPU 上，<font color='red'><b>共享内存被划分为多个存储 bank，每个 bank 宽度为 32 位</b></font>。**在一个 warp 内，访问不同 bank 的线程可以在一个周期内服务；否则，访问不同 bank 的线程会发生 bank 冲突，从而影响性能**。通过在每 64 个 int32 项之后填充 8 个 int32 项，可以避免每个 warp 内的 bank 冲突。

----

![[8-第八章：共享内存的合理使用#8.3 避免共享内存的bank冲突 ⭐️]]

---


#### 4.2.3-带 int4 矩阵 B 的高效在线转置

在线转置策略在使用int8的B矩阵时效果良好。然而，对于使用int4的B矩阵，它可能仍然会导致较高的开销。在采用图4中所示的类似无冲突共享内存访问方法后，每个线程在本地寄存器中存储8\*8=64个int4值。由于CUDA中没有对应于4位整数的数据类型，在本地寄存器上转置这64个int4值会导致大量的位运算。

![image.png|center|400](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250225200745.png)


因此，我们提出了一种新的列索引打散策略，以实现int4值的高效转置，如图7所示。❶我们通过以块的方式（块大小=8）打散左侧稀疏矩阵的列索引，修改SR-BCRS格式。这种打散的目的是在最后一步中得到体现。❷将相应的右侧数据块加载到寄存器中，类似于int8。在❸和❹中，局部寄存器上的数据以int8（char）为粒度进行转置。❺转置后的每一行被划分为两个int32值。在❻和❼中，经过掩码、位移和逐位或操作，我们得到一个只包含低4位值的int32和另一个只包含前面两个int32值高4位值的int32。每个int32中包含8个int4值，而每个int4值上的数字表示对应列索引的ID。令人惊讶的是，相关的列索引被恢复到打散前的状态，转置也完成了。这个过程的关键好处在于，<font color='red'><b>位运算仅在int32粒度下进行，而非int4。仅使用8个位运算，就完成了16个int4值的转置</b></font>，这显著减少了与直接使用int4值转置相比的开销。

#### 4.2.4-RHS 矩阵 B 的预取

如在第IV-B2节中讨论的，**右侧矩阵B的数据块被加载到共享内存中以进行转置**。然而，<font color='red'><b>由于矩阵A是稀疏的，矩阵B在共享内存中的数据没有重用。因此，为了减轻矩阵B内存流量的成本，我们建议使用数据预取策略</b></font>，如算法1所示。

![image.png|center|400](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250225201506.png)

> [! warning] 💡：流水线的设计！！！

回想一下，每个线程块需要$nnz/BS_k$个累加步骤来获得最终结果。此外，从全局内存加载数据到共享内存时，有两个阶段：
- a) 从全局内存加载数据到寄存器
- b) 将寄存器中的数据存储到共享内存。
因此，我们将从全局到共享的加载分为两个阶段，并组成一个pipeline。在for循环的第一次迭代中，第7-9行和第11行是pipeline的冷启动，此后来自矩阵A和B的第一个块被加载到共享内存中。然后，for循环中的第11-16行形成pipeline的主体。第12行加载左侧稠密向量及其对应的列索引到共享内存以供下一次迭代。在第14行中，使用列索引将右侧数据块预取到寄存器中，这与第15行当前步骤的mma计算重叠。因此，右侧数据块的全局内存访问延迟被隐藏。请注意，线程块级的同步被插入到管道中以实现线程安全。

---

在CUDA编程中，这种基于共享内存（__shared__）、寄存器（__registers__）以及__syncthreads()的流水线（Pipeline）设计确实能够提高计算效率，特别是对于**稀疏矩阵乘法（SpMM）**或其他涉及数据复用的计算场景。：
1. **减少全局内存访问延迟**
	- 该算法将LHS和RHS数据分别加载到共享内存和寄存器中，通过Load_LHS_values_and_indices_to_shared(i)和Prefetch_RHS_values_to_registers(i)的预取操作，减少了直接从全局内存访问数据的次数。这种技术可以显著降低全局内存访问的延迟，从而提高计算吞吐量。
2. **隐藏数据加载延迟（Latency Hiding）**
	- 该流水线采用了**双缓冲（Double Buffering）** 的方式，每次计算时都会预取下一步计算需要的数据。这种策略可以通过并行化计算与数据传输，使得计算核心（CUDA Cores）在执行MMA_compute_tiles(i-1)计算的同时，预取下一个时间步的数据，避免因等待数据加载而导致的计算停滞。
3. **同步（Synchronization）控制流水线阶段**
	- __syncthreads()保证了不同线程块（Thread Blocks）在共享内存数据加载完成后再进行计算，避免了竞争条件（Race Condition）。这对于保持数据一致性至关重要，尤其是当多个线程需要共享LHS和RHS数据时。
4. **寄存器数据预取优化**
	- Prefetch_RHS_values_to_registers(i)将部分RHS数据提前加载到寄存器中，使得计算时可以直接从寄存器读取数据，而不必频繁访问共享内存或全局内存。由于寄存器是CUDA设备上最快的存储层级，这种优化可以减少访问延迟，提高吞吐量。
5. **计算与数据加载交错执行**
	- for循环中的操作顺序使得前一步的计算可以在下一步的数据加载完成之前进行，形成类似流水线的效果：
		- 先存储前一轮的RHS数据到共享内存
		- 加载当前LHS和索引数据
		- 预取下一轮RHS数据到寄存器
		- 执行MMA（矩阵乘累加）计算

这种模式使得计算任务与数据搬运任务相互交错，从而提高整体计算效率。

**可能的优化方向**
- **利用CUDA的异步流水线**（如cudaMemcpyAsync + cudaStream）来进一步隐藏数据传输的开销
- **调整BSk的大小**，选择合适的批大小，使得共享内存和寄存器的使用能达到最佳平衡，避免浪费。

---


### 4.3-在Magicube中的SDDMM

采样稠密-稠密矩阵乘法（SDDMM）是深度学习中的另一种主要稀疏工作负载。SDDMM的输出是一个稀疏矩阵。例如，在剪枝模型的前向传播中，稀疏权重梯度的计算就是一个SDDMM操作。<font color='red'><b>在稀疏Transformers中，稀疏注意力权重的计算也是一个SDDMM操作</b></font>。

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250225202301.png)

图8(a)展示了一个SDDMM的例子，其中输出矩阵C具有结构稀疏性（即1-D块）。稠密向量的列索引用于加载矩阵B的相应列。

#### 4.3.1-SDDMM的线程块

图8(b)展示了在Magicube中在线程块级别实现SDDMM的过程。我们对A使用行主存储，对B使用列主存储。假设我们在一个线程块中有2个warp。每个线程块负责一个大小为$BS_m*BS_n$的稠密输出块。与SpMM类似，我们设置$BS_m=V$且$V<=8$。在每一步中，每个线程块使用归约维度$BS_k$计算部分结果。这里$BS_k$等于$mma$的归约维度。总体来说，每个线程块需要$nnz/BS_k$步（部分结果被累加）来获得最终结果。

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250225231753.png)

LHS块被加载到共享内存中，并在多个warp之间共享。我们还使用类似于算法1的策略来预取LHS数据块。由于在共享内存中RHS块没有数据重复使用，并且B以列主序存储，每个线程直接将相应的数据加载到本地寄存器中，并满足mma的数据布局要求。mma操作的warp级视图如图9所示。注意，**输出稀疏矩阵C的格式由后续操作决定。如果后续操作是SpMM，则C输出为SR-BCRS格式；如果后续操作是softmax，则C输出为BCRS格式**。


### 4.4-混合精度仿真

对于SpMM，Magicube支持矩阵A的精度高于矩阵B的情况，例如，A是int8而B是int4。<font color='red'><b>混合精度的量化方案在机器学习领域得到了广泛研究</b></font>。由于A已经是稀疏的，A的更高精度可能带来更高的模型准确性。Magicube还支持A和B都是int16的情况（在Tensor核心上不原生支持），适用于SpMM和SDDMM。**这个想法是将高精度值划分为若干低精度值，然后从数学上模拟矩阵乘法**。使用1位mma原语对无符号整数进行GEMM（密集矩阵乘法）的任意精度仿真已在相关研究中探讨，这需要进行x * y次1位整数的矩阵乘法，其中x和y分别是左侧和右侧矩阵中值的位数。为了在混合精度和低仿真开销之间进行权衡，我们只考虑位数是4或8的倍数的精度。与以前的工作不同，我们支持无符号和有符号整数的精度仿真。

#### 4.4.1-无符号整数仿真

这里我们以矩阵乘法 $A$ (无符号 $int8$) * $B$ (无符号 $int4$) 为例。假设 $a = 11101101 = 237$ (十进制) 是从矩阵 $A$ 中随机选择的一个标量。然后，我们可以直接将 $a$ 分解为两个无符号 $int4$ 值，包括 $a_0 = 1101 = 13$ (十进制) 代表低4位和 $a_1 = 1110 = 14$ (十进制) 代表高4位。通过数学仿真，原始的8位值 $a$ 可以通过以下方式恢复：
$$

a = a_0 + 2^4 \cdot a_1

$$
因此，矩阵 $A$ 可以分解为 $A_0$ 包含所有低4位的值，$A_1$ 包含所有高4位的值，如图10(a)所示。将 $A_0$ 和 $A_1$ 与 $B$ 相乘，生成两个中间矩阵 $C_0$ 和 $C_1$。由于标量 $a$ 的数学仿真是线性函数，最终输出矩阵 $C$ 可以相应地仿真，即

$$

C = C_0 + 2^4 \cdot C_1

$$

其中 $+$ 表示逐元素相加。需要注意的是，在没有混合精度仿真的情况下，矩阵 $B$ 必须转换为 $int8$，这会显著增加内存消耗。

#### 4.4.2-有符号整数仿真

深度学习模型也可以通过对称量化将其量化为有符号整数。在计算机中，签名整数是以二补码表示的。例如，8位签名整数 $-19$（十进制）编码为 $11101101$。我们直接将其分解为两个4位整数（即 $1110$ 和 $1101$）。然而，为了保证数学正确性，必须将高4位视为有符号整数（即 $-2$），而将低4位视为无符号整数（即 $13$）。然后，数学仿真 $-2 \times 16 + 13$ 将恢复两个4位整数为原始的8位整数（即 $-19$）。这意味着，在矩阵乘法的混合精度仿真中（图10(a)），左侧（LHS）和右侧（RHS）矩阵具有不同类型的整数（即，签名和无符号）。幸运的是，Tensor 核上的 $mma$ 原语支持左侧是有符号，右侧是无符号，反之亦然。通过将最高4位视为有符号整数，其他位视为无符号整数，Magicube 支持混合精度仿真，用于带符号整数的矩阵乘法。

#### 4.4.3-Magicube中的支持精度

![image.png|center|500](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250225232653.png)

Magicube 中支持的精度列在表 IV 中，其中 $L_x - R_y$ 表示一个 $x$ 位的左侧（LHS）矩阵与一个 $y$ 位的右侧（RHS）矩阵相乘。

## 5-Evaluation

我们在NVIDIA A100 GPU (A100-SXM4-40GB GPU)上评估性能。A100 GPU具有108个SM，每个SM拥有总共192KB可配置的L1缓存和共享内存，以及256KB寄存器。我们将Magicube的性能与稀疏库（cuSPARSE、vectorSparse）和稠密库（cuBLAS、cuDNN）进行比较。我们使用**深度学习矩阵集合(DLMC)稀疏矩阵数据集**构建基准测试，该数据集类似于稀疏矩阵通过用1-D向量（V = 2、4、8）替换每个标量进行扩展。VectorSparse使用BCRS格式（即列向量稀疏编码）。Magicube使用如图2所示的SR-BCRS格式。由于cuSPARSE支持基于Blocked-ELL格式的SpMM，因此生成与BCRS和SR-BCRS具有相同稀疏性和问题大小的BlockedELL格式。对于SpMM，稀疏矩阵用于LHS矩阵；在SDDMM中，稀疏矩阵用于输出矩阵。

我们评估不同稀疏性的性能，包括0.5、0.7、0.8、0.9、0.95和0.98。对于每个稀疏性，我们从DLMC选择256个不同大小的矩阵，涵盖了ResNet-50模型中的所有稀疏矩阵以及Transformer模型中的部分稀疏矩阵。总的来说，评估中使用了来自DLMC的1,536个稀疏矩阵，使用不同的向量长度进行扩展（即V = 2、4、8）。

### 5.1-评估 Magicube 的优化策略

首先，我们使用来自DLMC的一个稀疏矩阵（M=256，N=512，K=2304）来评估为SpMM提出的优化方法。

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250225235621.png)

结果如图11所示，其中Lx-Ry表示x位LHS矩阵和y位RHS矩阵。通过这项<font color='red'><b>消融研究</b></font>，我们可以看到在第IV-B节中讨论的所有优化方法（包括无冲突的共享内存访问、对RHL数据块的数据预取以及针对4位整数的列索引洗牌）都非常有效。特别是，针对4位整数提出的列索引洗牌显著提高了性能。在L4-R4的情况下，V=8且稀疏度=0.7，列索引洗牌策略在所有其他优化被使用后，进一步提高了1.45倍的性能。

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250226000236.png)

在第四节D中讨论过，Magicube支持精度仿真。图12展示了混合精度下的SpMM性能。一方面，主要趋势是我们使用的精度越低，能够达到的性能越高。但也有一些例外，例如，当稀疏度为0.98时，L16-R4的性能低于L8-R8，这是因为在稀疏度高时，内存节省的好处无法抵消仿真开销。另一方面，当LHS精度相同时，RHS矩阵的更高精度并不会显著降低性能，这显示了Magicube中精度仿真策略的效率。回忆一下，我们还为SDDMM的LHS数据块使用了数据预取。但图13中的结果显示，为SDDMM预取LHS数据并没有好处。这是因为SDDMM中的LHS数据块在不同warp之间是共享和重用的。因此，即使没有预取，它也已经展现出良好的性能。

### 5.2-与现有稠密和稀疏矩阵库的比较

接下来，我们将Magicube的性能与其他稠密和稀疏库进行比较。

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250226003143.png)

图14显示了SpMM的性能。我们将Magicube与不同精度的cuBLAS（fp16，int8）、vectorSparse（fp16）和cuSPARSE（fp16，int8）进行比较。图中显示的加速比是以cuBLAS（fp16）为基准进行归一化的。我们可以看到，Magicube显著优于所有稀疏库。Magicube在稀疏度超过0.7的情况下，甚至在 $V<8$ 时也能比cuBLAS（fp16）实现实际加速。有一个有趣的点是，cuBLAS（int8）的表现甚至比cuBLAS（fp16）更差。在V=8和N=256的情况下，Magicube（L8-R8）在所有1,536个矩阵中平均（几何平均）比cuSPARSE（int8）快1.44倍（最高可达2.37倍），并且在所有1,536个矩阵中平均比cuBLAS（int8，稠密）快2.88倍（最高可达15.26倍）；Magicube（L16-R8）在所有1,536个矩阵中平均比vectorSparse（fp16）快2.50倍（最高可达5.27倍）。

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250226003158.png)

图15显示了SDDMM的性能。我们将Magicube与不同精度的cuBLAS（fp16，int8）和vectorSparse（fp16）进行比较。图中显示的加速比是以cuBLAS（fp16）为基准进行归一化的。与SpMM类似，Magicube的SDDMM在稀疏度超过0.7时开始实现相对于cuBLAS（fp16）的实际加速。在V=8和K=256的情况下，Magicube（L16-R16）在所有1,536个矩阵中平均比vectorSparse（fp16）快1.58倍（最高可达2.15倍）。Magicube在较低精度下实现了更高的加速。这些结果表明了Magicube中色化稀疏内核的高效性。

### 5.3-端到端稀疏Transformer推理的案例研究

Transformer模型已广泛应用于自然语言处理和计算机视觉领域，并展现出优秀的学习能力，这得益于多头注意力等技术。目前，Transformer是大规模模型工作负载的典型代表。<font color='red'><b>Transformer模型通常具有重复的结构（即相同的块重复多次）</b></font>。网络架构和模型大小主要由**头部维度**、**头部数量**和**层数**决定。此外，自注意力的工作负载随着输入序列长度的平方增长。通过改变上述参数，我们的评估涵盖了不同的Transformer架构和工作负载。

我们评估了Magicube在真实应用中的性能，以及使用来自长程竞技场（LRA）的稀疏Transformer模型进行端到端推理。该模型有4个编码器层。稀疏Transformer在自注意力操作中具有SDDMM和SpMM的工作负载，使用稀疏注意力掩码。

$$

Attention(Q,K,V) = \text{softmax} \left( \frac{QK^T \odot M}{\sqrt{d_k}} \right) V

$$

其中$d_k$是头部维度（$d_k = 64$），$M \in {0, 1}^{L \times L}$是稀疏注意力掩码矩阵，其中$L$是序列长度，$\odot$表示逐元素乘法。对于稀疏注意力掩码矩阵，我们遵循Chen等人的做法，加入8x1向量稀疏性约束。

![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250226003757.png)

图16展示了我们实现的一个量化的自注意力层，带有稀疏掩码。首先，我们对$Q$、$K$、$V$矩阵进行量化（这里$Q$、$K$、$V$是投影的输出）。接下来，稀疏掩码矩阵决定了$QK^T$输出的稀疏性。然后，$QK^T$将进行量化的SDDMM操作。我们将去量化与SDDMM操作融合。接下来，SDDMM的输出将是半精度的（fp16）。接着，我们在fp16下进行softmax核的计算，并将量化与softmax核融合，因此softmax的输出是一个稀疏的int8矩阵。最后，我们将int8的稀疏注意力权重与密集矩阵$V$（int8格式）相乘，这是一个SpMM操作。在这里，我们将去量化与SpMM操作融合，输出一个密集矩阵（fp16格式），这个矩阵将作为输入进一步传递到接下来的MLP层。


![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250226004129.png)

图17展示了针对不同稀疏性、序列长度、头数、批量大小和精度的稀疏Transformers的端到端推理延迟结果。我们将编码器层的数量保持为4，因为总工作量与层数成正比，并将头维度保持为64，这在Transformer模型中常见。对于Magicube，xb-yb表示将softmax的输出量化为x位整数，并将Q、K、V量化为y位整数。我们将我们的实现与fp16稠密对应物（PyTorch 1.9与cuDNN版本8005）和vectorSparse（fp16）进行比较。我们对每个配置进行了256次迭代，直方图上的绿色条形表示95%的置信区间。对于稀疏性=90%，seq_len=4,096，num_heads=4的端到端推理，Magicube在vectorSparse（在Tensor核心上使用fp16的最先进稀疏库）上实现了1.43x-1.63x的加速，并在PyTorch与cuDNN（稠密）上实现了1.50x-1.70x的加速。在将序列长度增加到8,192时，fp16稠密对应物在batchsize=8时内存耗尽，因为自注意力的内存开销随序列长度的增加而呈平方增长。当稀疏性=90%，seq_len=8,192，num_heads=4时，Magicube在vectorSparse上实现了1.62x-1.92x的加速，这表明Magicube在较长序列上能够实现更高的加速。通过将num_heads从4增加到8，所有方案的运行时间增加了约2倍。通过将稀疏性从90%增加到95%，稀疏库（vectorSparse和Magicube）相比于稠密对应物进一步降低了延迟。


![image.png|center|600](https://cdn.jsdelivr.net/gh/NEUQer-xing/Markdown_images@master/images-2/20250226004238.png)

表V展示了使用稀疏Transformer进行文本分类的测试准确性结果，num_heads=4和seq_len=4,096。LRA的代码库使用的是过时的FLAX版本，我们无法运行，因此在PyTorch中重新实现了它。我们使用相同的超参数对模型进行了稠密和稀疏注意力掩码的训练，并进行了量化的微调。与使用cuDNN的PyTorch（稠密）和稀疏（稀疏率=90%）模型的fp16相比，稀疏（稀疏率=90%）的量化模型（16位softmax输出和8位Q、K、V）达到了相当的准确性。通过将softmax输出的精度降低到8位，准确性略有下降，这表明更高的softmax精度有助于保持准确性。在进一步将稀疏率增加到95%后，稀疏模型的准确性降至可接受范围内。

## 6-Discussion

### 6.1-对其他AI加速器的通用性
虽然Magicube是基于NVIDIA GPU和Tensor核心设计的，但Magicube的关键洞察可以轻松适应其他AI加速器。例如，AMD MI250X GPU提供383.0 TOP/s的峰值性能，适用于int8，通过Matrix Core技术实现。为了在Matrix核心上进行编程，AMD提供了具有Matrix Fused Multiply-Add（MFMA）语义的wavefront级指令。与NVIDIA GPU上的mma类似，MFMA指令（例如V_MFMA_I32_16X16X16I8）也对数据布局有特定要求。Magicube的技术，如SR-BCRS格式、在线转置和数据预取，也可以在这些加速器上使用。

### 6.2-与分布式深度学习系统协作
高效的大规模深度学习通常通过数据、操作符和流水线并行的组合在分布式系统上实现。Magicube可以作为后端计算库在这些分布式深度学习系统中使用，以加速每个（子）操作符并缓解计算瓶颈。如何在引入稀疏性和量化的同时保持收敛质量是我们未来的工作。

### 6.3-更多应用
在本研究中，我们专注于基于Transformer的超大规模模型，其中通过稀疏注意力掩码引入稀疏工作负载。我们的方案也可能对深度学习中的其他稀疏工作负载有所裨益。例如，模型剪枝训练导致前向传播中的SpMM和反向传播中的SDDMM。此外，我们的实证观察表明，二阶优化中的曲率矩阵也可能通过稀疏性来近似。


## 7-Conclusion

在本文中，我们提出了Magicube，一种在Tensor核心上使用低精度（8位、4位）整数的高性能稀疏矩阵库，旨在加速深度学习中的稀疏和量化矩阵运算，主要用于SpMM和SDDMM。为了压缩低精度整数的量，我们设计了一种<font color='red'><b>跨行主序BCRS（SR-BCRS）格式</b></font>。

通过对超过1536个各异大小和稀疏度（50-98%）的稀疏矩阵进行性能评估，数据来源于DLMC数据集，在NVIDIA A100 GPU上，我们证明Magicube在SpMM上相比cuSPARSE实现了平均1.44倍（最高可达2.37倍）的加速。我们还展示了在稀疏（90%）注意力图的<font color='red'><b>Transformer模型</b></font>的端到端推理中，Magicube在准确性相当的情况下，相比于vectorSparse（当前最先进的fp16稀疏库）实现了1.43倍的加速，相比于与cuDNN一起使用的PyTorch（fp16稠密库）实现了1.50倍的加速。

**我们稀疏内核对数据布局的唯一限制是，每个非零块为1维块，形状例如8×1、4×1、2×1**。在此限制下，Magicube成功地从深度学习工作负载中的稀疏性和量化中获得了实际的加速。我们预见该工作将激励未来对深度学习模型的稀疏化和量化方法的研究，从而更有效地利用现代加速器。


